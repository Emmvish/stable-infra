<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Examples - Stable Request</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ö°</text></svg>">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="nav-brand">
                <span class="logo">‚ö°</span>
                <span class="brand-name">Stable Request</span>
            </a>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="documentation.html">Documentation</a>
                <a href="examples.html" class="active">Examples</a>
                <a href="https://github.com/Emmvish/stable-request" target="_blank">GitHub</a>
            </div>
        </div>
    </nav>

    <div class="examples-hero">
        <div class="container">
            <h1>Production-Ready Examples</h1>
            <p>Real-world use cases demonstrating the power of stable-request</p>
        </div>
    </div>

    <div class="container examples-content">
        <div class="example-showcase">
            <div class="example-item">
                <div class="example-header">
                    <span class="example-number">01</span>
                    <h2>Multi-Source Data Synchronization Pipeline</h2>
                    <div class="example-tags">
                        <span class="tag">Non-Linear Workflow</span>
                        <span class="tag">Circuit Breaker</span>
                        <span class="tag">Caching</span>
                        <span class="tag">Rate Limiting</span>
                    </div>
                </div>
                
                <div class="example-description">
                    <p>A comprehensive data synchronization workflow that fetches data from multiple API endpoints, validates and transforms it, then uploads to an internal system with full observability.</p>
                    
                    <h4>Key Features:</h4>
                    <ul>
                        <li>‚úÖ Multi-phase workflow orchestration</li>
                        <li>‚úÖ Concurrent data fetching from multiple sources</li>
                        <li>‚úÖ Phase decision hooks with REPLAY action</li>
                        <li>‚úÖ Circuit breaker integration</li>
                        <li>‚úÖ Response caching with TTL</li>
                        <li>‚úÖ Rate limiting (50 requests per 10 seconds)</li>
                        <li>‚úÖ Exponential backoff retry strategy</li>
                        <li>‚úÖ Pre-execution hooks for data enrichment</li>
                        <li>‚úÖ Shared buffer for cross-phase state management</li>
                    </ul>
                    
                    <h4>Use Case:</h4>
                    <p>Enterprise data synchronization from external APIs with validation, transformation, and batch uploading.</p>
                </div>
                
                <div class="example-code">
                    <div class="example-actions">
                        <button class="btn btn-primary run-example-btn" data-example="01">
                            ‚ñ∂ Run Example
                        </button>
                        <button class="btn btn-secondary clear-output-btn" data-example="01" style="display:none;">
                            Clear Output
                        </button>
                    </div>
                    <div class="example-output" id="output-01" style="display:none;"></div>
                    <h4>Workflow Structure</h4>
                    <pre><code class="language-typescript">const syncPhases: STABLE_WORKFLOW_PHASE[] = [
  // Phase 1: Fetch data concurrently
  {
    id: 'fetch-source-data',
    concurrentExecution: true,
    requests: [
      { id: 'fetch-users', requestOptions: {...} },
      { id: 'fetch-posts', requestOptions: {...} },
      { id: 'fetch-comments', requestOptions: {...} }
    ]
  },
  
  // Phase 2: Data enrichment
  {
    id: 'enrich-data',
    requests: [{
      id: 'enrich-posts-with-users',
      requestOptions: {
        preExecution: {
          preExecutionHook: ({ commonBuffer }) => {
            // Enrich posts with user and comment data
            buffer.enrichedData = buffer.posts.map(post => ({
              ...post,
              author: findUser(post.userId),
              commentCount: countComments(post.id)
            }));
          }
        }
      }
    }]
  },
  
  // Phase 3: Validation with conditional retry
  {
    id: 'validate-data',
    allowReplay: true,
    maxReplayCount: 2,
    requests: [{ id: 'validate', requestOptions: {...} }],
    phaseDecisionHook: async ({ phaseResult, retryCount }) => {
      if (hasValidationErrors && retryCount < 2) {
        return { action: PHASE_DECISION_ACTIONS.REPLAY };
      }
      return { action: PHASE_DECISION_ACTIONS.CONTINUE };
    }
  },
  
  // Phase 4: Batch upload
  {
    id: 'upload-data',
    concurrentExecution: true,
    requests: enrichedData.map(item => ({
      id: `upload-${item.id}`,
      requestOptions: { 
        reqData: { path: '/api/sync', method: 'POST', body: item }
      }
    }))
  }
];

// Execute workflow with shared circuit breaker
const result = await stableWorkflow(syncPhases, {
  workflowId: 'data-sync-pipeline',
  commonRequestData: { hostname: 'api.example.com' },
  commonAttempts: 3,
  commonWait: 1000,
  commonRetryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
  enableNonLinearExecution: true,
  circuitBreaker: sourceApiBreaker,
  commonCache: { ttl: 300000 },
  rateLimit: { maxRequests: 50, windowMs: 10000 },
  sharedBuffer: syncState,
  handlePhaseCompletion: async ({ phaseResult }) => {
    console.log(`Phase ${phaseResult.phaseId} completed in ${phaseResult.executionTime}ms`);
  }
});</code></pre>
                </div>
            </div>

            <div class="example-item">
                <div class="example-header">
                    <span class="example-number">02</span>
                    <h2>Resilient Microservice Orchestration</h2>
                    <div class="example-tags">
                        <span class="tag">Branched Workflows</span>
                        <span class="tag">Circuit Breakers</span>
                        <span class="tag">Request Grouping</span>
                        <span class="tag">Fallback Strategies</span>
                    </div>
                </div>
                
                <div class="example-description">
                    <p>A sophisticated microservice orchestration pattern coordinating user validation, inventory management, payment processing, and notifications with proper failure handling.</p>
                    
                    <h4>Key Features:</h4>
                    <ul>
                        <li>‚úÖ Branch workflow execution</li>
                        <li>‚úÖ Mixed concurrent and sequential branches</li>
                        <li>‚úÖ Multiple circuit breakers (one per service)</li>
                        <li>‚úÖ Request grouping with different retry policies</li>
                        <li>‚úÖ Branch decision hooks (REPLAY and TERMINATE actions)</li>
                        <li>‚úÖ Workflow termination on critical failures</li>
                        <li>‚úÖ Graceful handling of non-critical failures</li>
                        <li>‚úÖ Complex state management across branches</li>
                    </ul>
                    
                    <h4>Use Case:</h4>
                    <p>E-commerce order processing coordinating multiple microservices with isolated failure handling and proper SLA requirements.</p>
                </div>
                
                <div class="example-code">
                    <div class="example-actions">
                        <button class="btn btn-primary run-example-btn" data-example="02">
                            ‚ñ∂ Run Example
                        </button>
                        <button class="btn btn-secondary clear-output-btn" data-example="02" style="display:none;">
                            Clear Output
                        </button>
                    </div>
                    <div class="example-output" id="output-02" style="display:none;"></div>
                    <h4>Branch Workflow Structure</h4>
                    <pre><code class="language-typescript">// Separate circuit breakers for each service
const userServiceBreaker = new CircuitBreaker({
  failureThresholdPercentage: 50,
  minimumRequests: 5,
  recoveryTimeoutMs: 60000
});

const inventoryServiceBreaker = new CircuitBreaker({...});
const paymentServiceBreaker = new CircuitBreaker({...});

const branches: STABLE_WORKFLOW_BRANCH[] = [
  // Critical: User validation
  {
    branchId: 'user-service',
    concurrentBranch: false,
    phases: [
      {
        id: 'validate-user',
        requests: [{ 
          id: 'check-user',
          groupId: 'critical',
          requestOptions: {
            reqData: { path: '/users/validate', method: 'POST' },
            circuitBreaker: userServiceBreaker
          }
        }],
        phaseDecisionHook: async ({ phaseResult }) => {
          if (!phaseResult.success) {
            return { 
              action: PHASE_DECISION_ACTIONS.TERMINATE,
              terminateWorkflow: true  // Stop entire workflow
            };
          }
          return { action: PHASE_DECISION_ACTIONS.CONTINUE };
        }
      }
    ]
  },
  
  // Critical: Inventory management
  {
    branchId: 'inventory-service',
    concurrentBranch: false,
    phases: [
      { id: 'check-stock', requests: [...] },
      { id: 'reserve-items', requests: [...] }
    ]
  },
  
  // Critical: Payment processing
  {
    branchId: 'payment-service',
    concurrentBranch: false,
    phases: [
      { id: 'authorize-payment', requests: [...] },
      { id: 'capture-payment', requests: [...] }
    ]
  },
  
  // Optional: Notification service
  {
    branchId: 'notification-service',
    concurrentBranch: false,
    phases: [
      { id: 'send-notifications', requests: [...] }
    ]
  }
];

// Execute with branch-based workflow
const result = await stableWorkflow([], {
  workflowId: 'order-processing',
  enableBranchExecution: true,
  branches,
  concurrentBranchExecution: true,  // Branches run in parallel
  requestGroups: [
    {
      groupId: 'critical',
      commonAttempts: 5,
      commonRetryStrategy: RETRY_STRATEGIES.EXPONENTIAL
    },
    {
      groupId: 'optional',
      commonAttempts: 1  // Don't retry optional services
    }
  ],
  handleBranchCompletion: async ({ branchId, success }) => {
    if (!success && branchId !== 'notification-service') {
      logger.error(`Critical branch ${branchId} failed`);
    }
  }
});</code></pre>
                </div>
            </div>

            <div class="example-item">
                <div class="example-header">
                    <span class="example-number">03</span>
                    <h2>Production API Health Monitoring</h2>
                    <div class="example-tags">
                        <span class="tag">Health Checks</span>
                        <span class="tag">SLA Tracking</span>
                        <span class="tag">Alerting</span>
                        <span class="tag">Metrics</span>
                    </div>
                </div>
                
                <div class="example-description">
                    <p>A comprehensive health monitoring system that tracks service availability, response times, and SLA compliance with real-time alerting.</p>
                    
                    <h4>Key Features:</h4>
                    <ul>
                        <li>‚úÖ Individual service health checks with stableRequest</li>
                        <li>‚úÖ Circuit breaker per service</li>
                        <li>‚úÖ Exponential backoff retry strategy</li>
                        <li>‚úÖ Response caching with 5-second TTL</li>
                        <li>‚úÖ SLA threshold validation (200ms - 2000ms)</li>
                        <li>‚úÖ Consecutive failure tracking with alerting</li>
                        <li>‚úÖ Critical vs optional service differentiation</li>
                        <li>‚úÖ Real-time performance metrics</li>
                    </ul>
                    
                    <h4>Use Case:</h4>
                    <p>Production monitoring system tracking API health with automatic alerting on SLA breaches or consecutive failures.</p>
                </div>
                
                <div class="example-code">
                    <div class="example-actions">
                        <button class="btn btn-primary run-example-btn" data-example="03">
                            ‚ñ∂ Run Example
                        </button>
                        <button class="btn btn-secondary clear-output-btn" data-example="03" style="display:none;">
                            Clear Output
                        </button>
                    </div>
                    <div class="example-output" id="output-03" style="display:none;"></div>
                    <h4>Health Check Implementation</h4>
                    <pre><code class="language-typescript">interface ServiceHealth {
  serviceName: string;
  endpoint: string;
  isHealthy: boolean;
  responseTime: number;
  lastCheck: Date;
  consecutiveFailures: number;
  circuitBreakerState: string;
  slaCompliant: boolean;
}

// Configure services to monitor
const services = [
  { name: 'user-api', path: '/health', critical: true, slaMs: 500 },
  { name: 'order-api', path: '/health', critical: true, slaMs: 1000 },
  { name: 'notification-api', path: '/health', critical: false, slaMs: 2000 }
];

// Create circuit breaker for each service
const breakers = new Map();
services.forEach(service => {
  breakers.set(service.name, new CircuitBreaker({
    failureThresholdPercentage: 50,
    minimumRequests: 3,
    recoveryTimeoutMs: 30000
  }));
});

// Health check function
async function checkServiceHealth(service): Promise<ServiceHealth> {
  const breaker = breakers.get(service.name);
  const startTime = Date.now();
  
  try {
    const result = await stableRequest({
      reqData: {
        hostname: 'api.example.com',
        path: service.path,
        method: 'GET',
        timeout: 5000
      },
      resReq: true,
      attempts: 3,
      wait: 1000,
      retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
      circuitBreaker: breaker,
      cache: { ttl: 5000 },
      responseAnalyzer: async ({ status }) => {
        return status === 200;
      }
    });
    
    const responseTime = Date.now() - startTime;
    
    return {
      serviceName: service.name,
      endpoint: service.path,
      isHealthy: true,
      responseTime,
      lastCheck: new Date(),
      consecutiveFailures: 0,
      circuitBreakerState: breaker.getState().state,
      slaCompliant: responseTime <= service.slaMs
    };
  } catch (error) {
    return {
      serviceName: service.name,
      endpoint: service.path,
      isHealthy: false,
      responseTime: Date.now() - startTime,
      lastCheck: new Date(),
      consecutiveFailures: previousFailures + 1,
      circuitBreakerState: breaker.getState().state,
      slaCompliant: false
    };
  }
}

// Run health checks periodically
setInterval(async () => {
  const healthChecks = await Promise.all(
    services.map(service => checkServiceHealth(service))
  );
  
  healthChecks.forEach(health => {
    if (!health.isHealthy && health.consecutiveFailures >= 3) {
      alerting.critical(`Service ${health.serviceName} has failed 3 times`);
    }
    
    if (!health.slaCompliant) {
      alerting.warning(`Service ${health.serviceName} SLA breach: ${health.responseTime}ms`);
    }
    
    metrics.gauge(`service.health.${health.serviceName}`, health.isHealthy ? 1 : 0);
    metrics.gauge(`service.response_time.${health.serviceName}`, health.responseTime);
  });
}, 10000);</code></pre>
                </div>
            </div>

            <div class="example-item">
                <div class="example-header">
                    <span class="example-number">04</span>
                    <h2>Batch Image Processing Pipeline</h2>
                    <div class="example-tags">
                        <span class="tag">Batch Processing</span>
                        <span class="tag">Concurrency Control</span>
                        <span class="tag">Rate Limiting</span>
                        <span class="tag">Progress Tracking</span>
                    </div>
                </div>
                
                <div class="example-description">
                    <p>Process large batches of images through an external API with concurrency control, rate limiting, and progress tracking.</p>
                    
                    <h4>Key Features:</h4>
                    <ul>
                        <li>‚úÖ Batch request processing with stableApiGateway</li>
                        <li>‚úÖ Concurrency limiting (max 10 simultaneous)</li>
                        <li>‚úÖ Rate limiting to respect API quotas</li>
                        <li>‚úÖ Progress tracking and reporting</li>
                        <li>‚úÖ Retry on transient failures</li>
                        <li>‚úÖ Error aggregation and reporting</li>
                    </ul>
                </div>
                
                <div class="example-code">
                    <div class="example-actions">
                        <button class="btn btn-primary run-example-btn" data-example="04">
                            ‚ñ∂ Run Example
                        </button>
                        <button class="btn btn-secondary clear-output-btn" data-example="04" style="display:none;">
                            Clear Output
                        </button>
                    </div>
                    <div class="example-output" id="output-04" style="display:none;"></div>
                    <pre><code class="language-typescript">async function processBatchImages(imageUrls: string[]) {
  console.log(`Processing ${imageUrls.length} images...`);
  
  // Create requests for each image
  const requests = imageUrls.map((url, index) => ({
    id: `image-${index}`,
    requestOptions: {
      reqData: {
        hostname: 'image-api.example.com',
        path: '/process',
        method: 'POST',
        body: { imageUrl: url, operations: ['resize', 'optimize'] },
        timeout: 30000
      },
      resReq: true,
      attempts: 3,
      wait: 2000,
      retryStrategy: RETRY_STRATEGIES.EXPONENTIAL
    }
  }));
  
  // Process with concurrency and rate limiting
  const results = await stableApiGateway(requests, {
    concurrentExecution: true,
    maxConcurrentRequests: 10,        // Max 10 simultaneous
    rateLimit: {
      maxRequests: 100,
      windowMs: 60000                 // 100 requests per minute
    },
    commonHandleSuccessfulAttemptData: async ({ successfulAttemptData }, { requestId }) => {
      const progress = ((results.length / imageUrls.length) * 100).toFixed(1);
      console.log(`‚úÖ Processed ${requestId}: ${progress}% complete`);
    }
  });
  
  // Report results
  const successful = results.filter(r => r.success).length;
  const failed = results.filter(r => !r.success).length;
  
  console.log(`\nBatch processing complete:`);
  console.log(`  Total: ${imageUrls.length}`);
  console.log(`  Successful: ${successful}`);
  console.log(`  Failed: ${failed}`);
  
  return results;
}</code></pre>
                </div>
            </div>

            <div class="example-item">
                <div class="example-header">
                    <span class="example-number">05</span>
                    <h2>Feature Flag Testing with Trial Mode</h2>
                    <div class="example-tags">
                        <span class="tag">A/B Testing</span>
                        <span class="tag">Trial Mode</span>
                        <span class="tag">Feature Flags</span>
                        <span class="tag">Testing</span>
                    </div>
                </div>
                
                <div class="example-description">
                    <p>Test feature flags and new implementations without making real API calls using trial mode with configurable success rates.</p>
                    
                    <h4>Key Features:</h4>
                    <ul>
                        <li>‚úÖ Trial mode for testing without real requests</li>
                        <li>‚úÖ Configurable success/failure probabilities</li>
                        <li>‚úÖ A/B testing simulation</li>
                        <li>‚úÖ Mock data injection</li>
                        <li>‚úÖ Performance testing under various conditions</li>
                    </ul>
                </div>
                
                <div class="example-code">
                    <div class="example-actions">
                        <button class="btn btn-primary run-example-btn" data-example="05">
                            ‚ñ∂ Run Example
                        </button>
                        <button class="btn btn-secondary clear-output-btn" data-example="05" style="display:none;">
                            Clear Output
                        </button>
                    </div>
                    <div class="example-output" id="output-05" style="display:none;"></div>
                    <pre><code class="language-typescript">// Test different feature configurations
async function testFeatureFlag(featureName: string, config: any) {
  console.log(`Testing feature: ${featureName}`);
  
  const results = await stableRequest({
    reqData: {
      hostname: 'api.example.com',
      path: '/feature-test',
      method: 'POST',
      body: { feature: featureName, config }
    },
    resReq: true,
    attempts: 5,
    wait: 1000,
    retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
    trialMode: {
      trialModeOn: true,
      successProbability: config.expectedSuccessRate,
      trialModeData: {
        feature: featureName,
        enabled: true,
        config,
        timestamp: Date.now()
      }
    }
  });
  
  return results;
}

// Run A/B tests
const testScenarios = [
  { name: 'feature-A', config: { timeout: 5000 }, expectedSuccessRate: 0.95 },
  { name: 'feature-B', config: { timeout: 3000 }, expectedSuccessRate: 0.85 },
  { name: 'feature-C', config: { timeout: 1000 }, expectedSuccessRate: 0.60 }
];

for (const scenario of testScenarios) {
  const result = await testFeatureFlag(scenario.name, scenario.config);
  console.log(`${scenario.name}: ${result ? 'SUCCESS' : 'FAILED'}`);
}</code></pre>
                </div>
            </div>

            <div class="example-item">
                <div class="example-header">
                    <span class="example-number">06</span>
                    <h2>Distributed Workflow State Persistence</h2>
                    <div class="example-tags">
                        <span class="tag">State Persistence</span>
                        <span class="tag">Workflow Recovery</span>
                        <span class="tag">Distributed Systems</span>
                        <span class="tag">Redis</span>
                        <span class="tag">Checkpointing</span>
                    </div>
                </div>
                
                <div class="example-description">
                    <p>A production-grade distributed data processing workflow with Redis-based state persistence, enabling workflow recovery, resumption, and distributed execution across multiple instances.</p>
                    
                    <h4>Key Features:</h4>
                    <ul>
                        <li>‚úÖ State persistence to Redis with TTL</li>
                        <li>‚úÖ Workflow recovery and resumption after failures</li>
                        <li>‚úÖ Multi-stage data pipeline with checkpoints</li>
                        <li>‚úÖ Distributed lock mechanisms for safety</li>
                        <li>‚úÖ State versioning and audit trails</li>
                        <li>‚úÖ Real-time progress tracking across instances</li>
                        <li>‚úÖ Automatic cleanup of completed workflows</li>
                        <li>‚úÖ Phase completion tracking and skip logic</li>
                        <li>‚úÖ Hierarchical state keys for organization</li>
                        <li>‚úÖ Batch processing with concurrent migrations</li>
                    </ul>
                    
                    <h4>Use Case:</h4>
                    <p>Large-scale data migration pipeline that can be resumed from any checkpoint, run across multiple server instances, and provide real-time progress visibility. Perfect for long-running workflows that need resilience against failures.</p>
                </div>
                
                <div class="example-code">
                    <div class="example-actions">
                        <button class="btn btn-primary run-example-btn" data-example="06">
                            ‚ñ∂ Run Example
                        </button>
                        <button class="btn btn-secondary clear-output-btn" data-example="06" style="display:none;">
                            Clear Output
                        </button>
                    </div>
                    <div class="example-output" id="output-06" style="display:none;"></div>
                    <h4>Imports and Setup</h4>
                    <pre><code class="language-typescript">import { 
  stableWorkflow, 
  PHASE_DECISION_ACTIONS,
  REQUEST_METHODS,
  VALID_REQUEST_PROTOCOLS,
  type STABLE_WORKFLOW_PHASE,
  type StatePersistenceOptions
} from '../src/index.js';

/**
 * Redis-like storage for demonstration
 * In production, use actual Redis client (ioredis or node-redis)
 */
class StateStorage {
  private storage: Map<string, { value: string; expiresAt: number }> = new Map();

  async setex(key: string, ttl: number, value: string): Promise<void> {
    const expiresAt = Date.now() + (ttl * 1000);
    this.storage.set(key, { value, expiresAt });
    console.log(`    üíæ Stored state: ${key} (TTL: ${ttl}s)`);
  }

  async get(key: string): Promise<string | null> {
    const entry = this.storage.get(key);
    if (!entry || Date.now() > entry.expiresAt) return null;
    return entry.value;
  }
}

const stateStore = new StateStorage();

/**
 * Redis persistence function with distributed locking
 */
async function persistToRedis({ executionContext, params, buffer }) {
  const { workflowId, phaseId, branchId } = executionContext;
  const { ttl = 86400, enableLocking = false, namespace = 'workflow' } = params || {};
  
  // Generate hierarchical key
  const stateKey = `${namespace}:${workflowId}:${branchId || 'main'}:${phaseId || 'global'}`;
  const lockKey = `lock:${stateKey}`;
  
  const isStoring = buffer && Object.keys(buffer).length > 0;
  
  if (enableLocking) {
    // Acquire distributed lock
    await stateStore.setex(lockKey, 5, `${Date.now()}-${Math.random()}`);
  }
  
  try {
    if (isStoring) {
      // STORE MODE: Save state with metadata
      const stateWithMeta = {
        ...buffer,
        _meta: {
          workflowId,
          phaseId,
          timestamp: new Date().toISOString(),
          version: (buffer._meta?.version || 0) + 1
        }
      };
      
      await stateStore.setex(stateKey, ttl, JSON.stringify(stateWithMeta));
      
      // Create audit log entry
      const auditKey = `${namespace}:audit:${workflowId}:${Date.now()}`;
      await stateStore.setex(auditKey, ttl * 2, JSON.stringify({
        action: 'state_saved',
        phaseId,
        timestamp: new Date().toISOString(),
        stateSnapshot: stateWithMeta
      }));
    } else {
      // LOAD MODE: Retrieve state
      const data = await stateStore.get(stateKey);
      return data ? JSON.parse(data) : {};
    }
  } finally {
    if (enableLocking) {
      await stateStore.del(lockKey);
    }
  }
  
  return {};
}</code></pre>

                    <h4>Data Extraction with Mock Data</h4>
                    <pre><code class="language-typescript">// Phase 1: Extract source data (using mock data for demonstration)
{
  id: 'extract-source-data',
  concurrentExecution: false,
  requests: [{
    id: 'extract-users',
    requestOptions: {
      reqData: { 
        hostname: 'jsonplaceholder.typicode.com', 
        path: '/posts/1', 
        method: REQUEST_METHODS.GET 
      },
      resReq: false, // Don't make actual request
      preExecution: {
        preExecutionHook: ({ commonBuffer }) => {
          console.log('üì• Phase 1: Extracting source data...');
          const buffer = commonBuffer as WorkflowState;
          
          // Generate 100 mock records
          buffer.sourceRecords = Array.from({ length: 100 }, (_, i) => ({
            id: i + 1,
            name: `User ${i + 1}`,
            email: `user${i + 1}@example.com`,
            username: `user${i + 1}`,
            company: { name: `Company ${i % 10}` },
            address: { geo: { lat: '0.0', lng: '0.0' } }
          }));
          
          buffer.totalRecords = buffer.sourceRecords.length;
          buffer.progress = 20;
          console.log(`‚úÖ Extracted ${buffer.sourceRecords.length} records`);
          return {};
        }
      }
    }
  }],
  phaseDecisionHook: async ({ sharedBuffer }) => {
    // Check if phase already completed (recovery scenario)
    if (sharedBuffer.completedPhases.includes('extract-source-data')) {
      console.log('Phase already completed, skipping...');
      return { 
        action: PHASE_DECISION_ACTIONS.SKIP, 
        skipToPhaseId: 'transform-data' 
      };
    }
    
    if (sharedBuffer.sourceRecords.length > 0) {
      sharedBuffer.completedPhases.push('extract-source-data');
      return { action: PHASE_DECISION_ACTIONS.CONTINUE };
    }
    
    return { action: PHASE_DECISION_ACTIONS.TERMINATE };
  },
  statePersistence: {
    persistenceFunction: persistToRedis,
    persistenceParams: { ttl: 3600, enableLocking: true, namespace: 'migration' },
    loadBeforeHooks: true,
    storeAfterHooks: true
  }
},

// Phase 2: Transform data
{
  id: 'transform-data',
  requests: [{
    id: 'transform-records',
    requestOptions: {
      reqData: { 
        hostname: 'jsonplaceholder.typicode.com', 
        path: '/posts/1', 
        method: REQUEST_METHODS.GET 
      },
      resReq: false,
      preExecution: {
        preExecutionHook: ({ commonBuffer }) => {
          const buffer = commonBuffer as WorkflowState;
          
          buffer.transformedRecords = buffer.sourceRecords.map(record => ({
            id: record.id,
            externalId: record.id,
            name: record.name,
            email: record.email?.toLowerCase(),
            username: record.username,
            company: record.company?.name,
            metadata: {
              importedAt: new Date().toISOString(),
              source: 'jsonplaceholder',
              workflowId: WORKFLOW_ID
            }
          }));
          
          buffer.progress = 30;
          console.log(`‚úÖ Transformed ${buffer.transformedRecords.length} records`);
          return {};
        }
      }
    }
  }],
  phaseDecisionHook: async ({ phaseResult, sharedBuffer }) => {
    if (sharedBuffer.completedPhases.includes('transform-data')) {
      return { action: PHASE_DECISION_ACTIONS.SKIP, skipToPhaseId: 'validate-data' };
    }
    
    if (phaseResult.success && sharedBuffer.transformedRecords.length > 0) {
      sharedBuffer.completedPhases.push('transform-data');
      return { action: PHASE_DECISION_ACTIONS.CONTINUE };
    }
    
    // Retry logic using attemptCount from buffer
    if (sharedBuffer.attemptCount < 2) {
      sharedBuffer.attemptCount++;
      return { action: PHASE_DECISION_ACTIONS.REPLAY };
    }
    
    return { action: PHASE_DECISION_ACTIONS.TERMINATE };
  },
  allowReplay: true,
  maxReplayCount: 2,
  statePersistence: {
    persistenceFunction: persistToRedis,
    persistenceParams: { ttl: 3600, enableLocking: true, namespace: 'migration' },
    loadBeforeHooks: true,
    storeAfterHooks: true
  }
}</code></pre>

                    <h4>Workflow Execution Configuration</h4>
                    <pre><code class="language-typescript">// Execute workflow with global state persistence
const result = await stableWorkflow(migrationPhases, {
  workflowId: WORKFLOW_ID,
  commonRequestData: { 
    hostname: SOURCE_API,
    protocol: VALID_REQUEST_PROTOCOLS.HTTPS
  },
  enableNonLinearExecution: true,
  stopOnFirstPhaseError: false,
  maxWorkflowIterations: 100,
  sharedBuffer: workflowState,
  commonStatePersistence: {
    persistenceFunction: createCheckpoint,
    persistenceParams: { ttl: 7200 },
    loadBeforeHooks: true,
    storeAfterHooks: true
  },
  handlePhaseCompletion: async ({ phaseResult, sharedBuffer }) => {
    const buffer = sharedBuffer as WorkflowState;
    console.log(`‚úÖ Phase "${phaseResult.phaseId}" completed`);
    console.log(`   Duration: ${phaseResult.executionTime}ms`);
    console.log(`   Progress: ${buffer.progress}%`);
  },
  handlePhaseError: async ({ phaseResult, error, sharedBuffer }) => {
    const buffer = sharedBuffer as WorkflowState;
    console.error(`‚ùå Phase "${phaseResult.phaseId}" failed: ${error.message}`);
    buffer.errors.push(`Phase ${phaseResult.phaseId}: ${error.message}`);
  }
});</code></pre>

                    <h4>Workflow Recovery Pattern</h4>
                    <pre><code class="language-typescript">/**
 * Resume workflow from last checkpoint
 */
async function resumeWorkflow(workflowId: string) {
  // Load checkpoint from Redis
  const checkpointData = await redis.get(`checkpoint:${workflowId}`);
  const checkpoint = checkpointData ? JSON.parse(checkpointData) : {
    completedPhases: [],
    processedRecords: 0
  };
  
  console.log(`Resuming workflow from: ${checkpoint.lastPhase || 'start'}`);
  console.log(`Previously completed: ${checkpoint.completedPhases.join(', ')}`);
  
  // Execute workflow - completed phases will be automatically skipped
  const result = await stableWorkflow(migrationPhases, {
    workflowId,
    commonRequestData: { 
      hostname: SOURCE_API,
      protocol: VALID_REQUEST_PROTOCOLS.HTTPS
    },
    enableNonLinearExecution: true,
    sharedBuffer: {
      completedPhases: checkpoint.completedPhases,
      processedRecords: checkpoint.processedRecords,
      // ... restore other state
    },
    commonStatePersistence: {
      persistenceFunction: persistToRedis,
      persistenceParams: { ttl: 3600 },
      loadBeforeHooks: true,
      storeAfterHooks: true
    }
  });
  
  return result;
}

// Can be called multiple times - will resume from last checkpoint
await resumeWorkflow('migration-12345');</code></pre>
                </div>
            </div>
        </div>

        <section class="next-steps">
            <h2>Ready to Get Started?</h2>
            <p>Explore the documentation to learn how to implement these patterns in your own applications.</p>
            <div class="cta-buttons">
                <a href="documentation.html" class="btn btn-primary">View Documentation</a>
                <a href="https://github.com/Emmvish/stable-request/tree/main/examples" class="btn btn-secondary">View Full Examples on GitHub</a>
            </div>
        </section>
    </div>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4>stable-request</h4>
                    <p>Production-grade HTTP Workflow Engine for Node.js</p>
                </div>
                <div class="footer-section">
                    <h4>Links</h4>
                    <ul>
                        <li><a href="https://github.com/Emmvish/stable-request/blob/main/docs/api-references.md">API Reference</a></li>
                        <li><a href="https://github.com/Emmvish/stable-request/issues">Report Issues</a></li>
                        <li><a href="https://github.com/Emmvish/stable-request">GitHub</a></li>
                        <li><a href="https://www.npmjs.com/package/@emmvish/stable-request">npm</a></li>
                        <li><a href="index.html">Home</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Resources</h4>
                    <ul>
                        <li><a href="documentation.html">Documentation</a></li>
                        <li><a href="examples.html">Examples</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2026 Manish Varma (Emmvish).</p>
            </div>
        </div>
    </footer>

    <script>
        hljs.highlightAll();
        
        // Utility functions for logging
        function log(outputId, message, type = 'info') {
            const output = document.getElementById(`output-${outputId}`);
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                info: '#64b5f6',
                success: '#81c784',
                warning: '#ffb74d',
                error: '#e57373',
                phase: '#ba68c8'
            };
            const icons = {
                info: '‚ÑπÔ∏è',
                success: '‚úÖ',
                warning: '‚ö†Ô∏è',
                error: '‚ùå',
                phase: 'üìç'
            };
            const line = document.createElement('div');
            line.style.marginBottom = '8px';
            line.style.color = colors[type];
            line.innerHTML = `<span style="color: #78909c">[${timestamp}]</span> ${icons[type]} ${message}`;
            output.appendChild(line);
            output.parentElement.scrollTop = output.parentElement.scrollHeight;
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Simulate API call
        async function simulateRequest(endpoint, options = {}) {
            await delay(300 + Math.random() * 700);
            if (Math.random() > 0.1) { // 90% success rate
                return { success: true, data: options.mockData || { status: 'ok' } };
            }
            throw new Error('Request failed');
        }

        // Example 01: Data Synchronization Pipeline
        async function runExample01(outputId) {
            log(outputId, 'üöÄ Starting Multi-Source Data Synchronization Pipeline', 'info');
            log(outputId, 'Workflow ID: data-sync-pipeline', 'info');
            
            try {
                // Phase 1: Fetch data concurrently
                log(outputId, 'üìç Phase 1: Fetching data from multiple sources', 'phase');
                await delay(500);
                
                const sources = ['users', 'posts', 'comments'];
                for (const source of sources) {
                    log(outputId, `Fetching ${source}...`, 'info');
                    await simulateRequest(`/${source}`);
                    log(outputId, `‚úì ${source} fetched successfully`, 'success');
                    await delay(200);
                }
                log(outputId, 'Phase 1 completed in 1250ms', 'success');
                
                // Phase 2: Data enrichment
                log(outputId, 'üìç Phase 2: Enriching data', 'phase');
                await delay(500);
                log(outputId, 'Enriching posts with user data...', 'info');
                await delay(600);
                log(outputId, 'Enriching posts with comment counts...', 'info');
                await delay(400);
                log(outputId, '‚úì Enriched 25 posts with author and comment data', 'success');
                log(outputId, 'Phase 2 completed in 890ms', 'success');
                
                // Phase 3: Validation
                log(outputId, 'üìç Phase 3: Validating enriched data', 'phase');
                await delay(400);
                log(outputId, 'Running validation rules...', 'info');
                await delay(500);
                log(outputId, '‚úì All 25 records passed validation', 'success');
                log(outputId, 'Phase 3 completed in 650ms', 'success');
                
                // Phase 4: Batch upload
                log(outputId, 'üìç Phase 4: Uploading to internal system', 'phase');
                await delay(300);
                
                for (let i = 1; i <= 5; i++) {
                    log(outputId, `Uploading batch ${i}/5...`, 'info');
                    await simulateRequest('/api/sync', { mockData: { batchId: i } });
                    await delay(200);
                }
                log(outputId, '‚úì All batches uploaded successfully', 'success');
                log(outputId, 'Phase 4 completed in 1420ms', 'success');
                
                // Final summary
                await delay(300);
                log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
                log(outputId, 'üéâ Workflow completed successfully!', 'success');
                log(outputId, 'Total execution time: 4210ms', 'info');
                log(outputId, 'Successful requests: 28/28', 'success');
                log(outputId, 'Failed requests: 0', 'info');
            } catch (error) {
                log(outputId, `Workflow failed: ${error.message}`, 'error');
            }
        }

        // Example 02: Microservice Orchestration
        async function runExample02(outputId) {
            log(outputId, 'üöÄ Starting Microservice Orchestration', 'info');
            log(outputId, 'Workflow ID: order-processing', 'info');
            log(outputId, 'Mode: Concurrent branch execution', 'info');
            
            try {
                log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
                
                // Simulate concurrent branches
                const branches = [
                    { id: 'user-service', critical: true, phases: ['validate-user'] },
                    { id: 'inventory-service', critical: true, phases: ['check-stock', 'reserve-items'] },
                    { id: 'payment-service', critical: true, phases: ['authorize-payment', 'capture-payment'] },
                    { id: 'notification-service', critical: false, phases: ['send-notifications'] }
                ];
                
                log(outputId, `Starting ${branches.length} branches in parallel...`, 'info');
                await delay(300);
                
                for (const branch of branches) {
                    log(outputId, `üîÄ Branch: ${branch.id} (${branch.critical ? 'CRITICAL' : 'OPTIONAL'})`, 'phase');
                    
                    for (const phase of branch.phases) {
                        log(outputId, `  ‚û§ Phase: ${phase}`, 'info');
                        await delay(400);
                        
                        try {
                            await simulateRequest(`/${branch.id}/${phase}`);
                            log(outputId, `  ‚úì ${phase} completed`, 'success');
                        } catch (error) {
                            if (branch.critical) {
                                throw new Error(`Critical branch ${branch.id} failed`);
                            }
                            log(outputId, `  ‚ö†Ô∏è  ${phase} failed (non-critical)`, 'warning');
                        }
                        await delay(200);
                    }
                    
                    log(outputId, `‚úì Branch ${branch.id} completed`, 'success');
                    await delay(300);
                }
                
                log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
                log(outputId, 'üéâ Order processing completed successfully!', 'success');
                log(outputId, 'All critical branches: SUCCESS', 'success');
                log(outputId, 'Total branches: 4', 'info');
            } catch (error) {
                log(outputId, `Workflow failed: ${error.message}`, 'error');
                log(outputId, 'Initiating rollback procedures...', 'warning');
            }
        }

        // Example 03: API Health Monitoring
        async function runExample03(outputId) {
            log(outputId, 'üöÄ Starting API Health Monitor', 'info');
            log(outputId, 'Checking 3 services...', 'info');
            
            const services = [
                { name: 'user-api', sla: 500, critical: true },
                { name: 'order-api', sla: 1000, critical: true },
                { name: 'notification-api', sla: 2000, critical: false }
            ];
            
            log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
            
            for (const service of services) {
                log(outputId, `Checking ${service.name}...`, 'info');
                const startTime = Date.now();
                
                try {
                    await simulateRequest(`/${service.name}/health`);
                    const responseTime = Date.now() - startTime;
                    const slaCompliant = responseTime <= service.sla;
                    
                    if (slaCompliant) {
                        log(outputId, `‚úì ${service.name}: HEALTHY (${responseTime}ms, SLA: ${service.sla}ms)`, 'success');
                    } else {
                        log(outputId, `‚ö†Ô∏è  ${service.name}: SLA BREACH (${responseTime}ms > ${service.sla}ms)`, 'warning');
                    }
                    
                    log(outputId, `  Circuit Breaker: CLOSED`, 'info');
                    log(outputId, `  Consecutive Failures: 0`, 'info');
                } catch (error) {
                    log(outputId, `‚úó ${service.name}: UNHEALTHY`, 'error');
                    log(outputId, `  Circuit Breaker: OPEN`, 'warning');
                }
                
                await delay(400);
            }
            
            log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
            log(outputId, '‚úì Health check cycle completed', 'success');
            log(outputId, 'Healthy services: 3/3', 'success');
        }

        // Example 04: Batch Image Processing
        async function runExample04(outputId) {
            log(outputId, 'üöÄ Starting Batch Image Processing', 'info');
            
            const imageCount = 20;
            log(outputId, `Processing ${imageCount} images...`, 'info');
            log(outputId, 'Concurrency limit: 10', 'info');
            log(outputId, 'Rate limit: 100 requests/minute', 'info');
            
            log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
            
            let processed = 0;
            let successful = 0;
            let failed = 0;
            
            for (let i = 1; i <= imageCount; i++) {
                try {
                    await simulateRequest('/process-image', { mockData: { imageId: i } });
                    processed++;
                    successful++;
                    const progress = ((processed / imageCount) * 100).toFixed(1);
                    log(outputId, `‚úì Processed image-${i}: ${progress}% complete`, 'success');
                } catch (error) {
                    processed++;
                    failed++;
                    log(outputId, `‚úó Failed image-${i}`, 'error');
                }
                
                if (i % 5 === 0) await delay(300);
            }
            
            log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
            log(outputId, 'üéâ Batch processing complete!', 'success');
            log(outputId, `Total: ${imageCount}`, 'info');
            log(outputId, `Successful: ${successful}`, 'success');
            log(outputId, `Failed: ${failed}`, failed > 0 ? 'warning' : 'info');
        }

        // Example 05: Feature Flag Testing
        async function runExample05(outputId) {
            log(outputId, 'üöÄ Starting Feature Flag Testing', 'info');
            log(outputId, 'Testing 3 feature configurations with trial mode', 'info');
            
            const scenarios = [
                { name: 'feature-A', successRate: 0.95 },
                { name: 'feature-B', successRate: 0.85 },
                { name: 'feature-C', successRate: 0.60 }
            ];
            
            log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
            
            for (const scenario of scenarios) {
                log(outputId, `Testing ${scenario.name}...`, 'info');
                log(outputId, `  Expected success rate: ${(scenario.successRate * 100)}%`, 'info');
                
                let attempts = 5;
                let successes = 0;
                
                for (let i = 1; i <= attempts; i++) {
                    const success = Math.random() < scenario.successRate;
                    if (success) {
                        successes++;
                        log(outputId, `  Attempt ${i}: SUCCESS`, 'success');
                    } else {
                        log(outputId, `  Attempt ${i}: FAILED`, 'error');
                    }
                    await delay(200);
                }
                
                const actualRate = (successes / attempts * 100).toFixed(0);
                log(outputId, `‚úì ${scenario.name} completed: ${actualRate}% success rate`, 'success');
                await delay(400);
            }
            
            log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
            log(outputId, 'üéâ A/B testing completed!', 'success');
        }

        // Example 06: State Persistence Workflow
        async function runExample06(outputId) {
            log(outputId, 'üöÄ Starting Distributed Workflow with State Persistence', 'info');
            log(outputId, 'Workflow ID: migration-12345', 'info');
            log(outputId, 'Using Redis-based state persistence', 'info');
            
            log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
            
            try {
                // Phase 1: Extract
                log(outputId, 'üìç Phase 1: Extract source data', 'phase');
                await delay(500);
                log(outputId, 'üì• Extracting source data...', 'info');
                await delay(600);
                log(outputId, '‚úì Extracted 100 records', 'success');
                log(outputId, 'üíæ Stored state: migration:migration-12345:main:extract-source-data (TTL: 3600s)', 'info');
                log(outputId, 'Progress: 20%', 'info');
                await delay(300);
                
                // Phase 2: Transform
                log(outputId, 'üìç Phase 2: Transform data', 'phase');
                await delay(500);
                log(outputId, 'Loading previous state from Redis...', 'info');
                await delay(400);
                log(outputId, '‚úì State loaded: 100 source records', 'info');
                log(outputId, 'Transforming records...', 'info');
                await delay(700);
                log(outputId, '‚úì Transformed 100 records', 'success');
                log(outputId, 'üíæ Stored state: migration:migration-12345:main:transform-data (TTL: 3600s)', 'info');
                log(outputId, 'Progress: 40%', 'info');
                await delay(300);
                
                // Phase 3: Validate
                log(outputId, 'üìç Phase 3: Validate data', 'phase');
                await delay(500);
                log(outputId, 'Loading previous state from Redis...', 'info');
                await delay(400);
                log(outputId, 'Running validation rules...', 'info');
                await delay(600);
                log(outputId, '‚úì All records validated', 'success');
                log(outputId, 'üíæ Stored state: migration:migration-12345:main:validate-data (TTL: 3600s)', 'info');
                log(outputId, 'Progress: 60%', 'info');
                await delay(300);
                
                // Phase 4: Load
                log(outputId, 'üìç Phase 4: Load to destination', 'phase');
                await delay(500);
                log(outputId, 'Uploading records in batches...', 'info');
                
                for (let i = 1; i <= 5; i++) {
                    await delay(400);
                    log(outputId, `  Batch ${i}/5 uploaded (${i * 20} records)`, 'success');
                    const progress = 60 + (i * 8);
                    log(outputId, `  Progress: ${progress}%`, 'info');
                }
                
                log(outputId, 'üíæ Stored final state (TTL: 7200s)', 'info');
                log(outputId, 'Progress: 100%', 'success');
                
                log(outputId, '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
                log(outputId, 'üéâ Workflow completed successfully!', 'success');
                log(outputId, 'Total records processed: 100', 'success');
                log(outputId, 'Workflow can be resumed from any checkpoint', 'info');
                log(outputId, 'State persisted with distributed locking', 'info');
            } catch (error) {
                log(outputId, `Workflow interrupted: ${error.message}`, 'error');
                log(outputId, 'üíæ State checkpoint saved - can resume later', 'warning');
            }
        }

        // Event handlers
        document.querySelectorAll('.run-example-btn').forEach(button => {
            button.addEventListener('click', async function() {
                const exampleId = this.getAttribute('data-example');
                const output = document.getElementById(`output-${exampleId}`);
                const clearBtn = document.querySelector(`.clear-output-btn[data-example="${exampleId}"]`);
                
                // Show output and clear button
                output.style.display = 'block';
                output.innerHTML = '';
                clearBtn.style.display = 'inline-block';
                
                // Disable button during execution
                this.disabled = true;
                this.textContent = '‚è≥ Running...';
                
                // Run the appropriate example
                try {
                    switch(exampleId) {
                        case '01': await runExample01(exampleId); break;
                        case '02': await runExample02(exampleId); break;
                        case '03': await runExample03(exampleId); break;
                        case '04': await runExample04(exampleId); break;
                        case '05': await runExample05(exampleId); break;
                        case '06': await runExample06(exampleId); break;
                    }
                } catch (error) {
                    log(exampleId, `Unexpected error: ${error.message}`, 'error');
                }
                
                // Re-enable button
                this.disabled = false;
                this.textContent = '‚ñ∂ Run Example';
            });
        });

        // Clear output handlers
        document.querySelectorAll('.clear-output-btn').forEach(button => {
            button.addEventListener('click', function() {
                const exampleId = this.getAttribute('data-example');
                const output = document.getElementById(`output-${exampleId}`);
                output.innerHTML = '';
                output.style.display = 'none';
                this.style.display = 'none';
            });
        });
        
        // Add copy buttons to all code blocks
        document.querySelectorAll('pre code').forEach((codeBlock) => {
            const pre = codeBlock.parentElement;
            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = 'Copy';
            button.setAttribute('aria-label', 'Copy code to clipboard');
            
            button.addEventListener('click', async () => {
                const code = codeBlock.textContent;
                try {
                    await navigator.clipboard.writeText(code);
                    button.textContent = 'Copied!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    button.textContent = 'Failed';
                    setTimeout(() => {
                        button.textContent = 'Copy';
                    }, 2000);
                }
            });
            
            pre.style.position = 'relative';
            pre.appendChild(button);
        });
        
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    </script>
</body>
</html>
