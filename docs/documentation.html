<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation - Stable Request</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚡</text></svg>">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="nav-brand">
                <span class="logo">⚡</span>
                <span class="brand-name">Stable Request</span>
            </a>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="documentation.html" class="active">Documentation</a>
                <a href="examples.html">Examples</a>
                <a href="https://github.com/Emmvish/stable-request" target="_blank">GitHub</a>
            </div>
        </div>
    </nav>

    <div class="docs-container">
        <aside class="docs-sidebar">
            <div class="sidebar-content">
                <h3>Documentation</h3>
                <ul class="docs-nav">
                    <li><a href="#installation">Installation</a></li>
                    <li><a href="#core-functions">Core Functions</a>
                        <ul>
                            <li><a href="#stable-request">stableRequest</a></li>
                            <li><a href="#stable-api-gateway">stableApiGateway</a></li>
                            <li><a href="#stable-workflow">stableWorkflow</a></li>
                        </ul>
                    </li>
                    <li><a href="#config-cascading">Configuration Cascading</a>
                        <ul>
                            <li><a href="#api-gateway-cascading">API Gateway Cascading</a></li>
                            <li><a href="#workflow-cascading">Workflow Cascading</a></li>
                        </ul>
                    </li>
                    <li><a href="#state-buffers">State Buffers</a></li>
                    <li><a href="#retry-strategies">Retry Strategies</a></li>
                    <li><a href="#circuit-breaker">Circuit Breaker</a></li>
                    <li><a href="#caching">Response Caching</a></li>
                    <li><a href="#rate-limiting">Rate Limiting</a></li>
                    <li><a href="#workflow-patterns">Workflow Patterns</a>
                        <ul>
                            <li><a href="#sequential-concurrent">Sequential & Concurrent</a></li>
                            <li><a href="#mixed-execution">Mixed Execution</a></li>
                            <li><a href="#non-linear">Non-Linear Workflows</a></li>
                            <li><a href="#branched">Branched Workflows</a></li>
                        </ul>
                    </li>
                    <li><a href="#observability">Observability</a></li>
                    <li><a href="#pre-execution">Pre-Execution Hook</a></li>
                    <li><a href="#trial-mode">Trial Mode</a></li>
                    <li><a href="#state-persistence">State Persistence</a></li>
                    <li><a href="#best-practices">Best Practices</a></li>
                    <li><a href="https://github.com/Emmvish/stable-request/blob/main/docs/api-references.md" target="_blank">API Reference</a></li>
                </ul>
            </div>
        </aside>

        <main class="docs-main">
            <section id="installation" class="doc-section">
                <h1>Documentation</h1>
                <p class="lead">Complete guide to using stable-request for production-grade HTTP workflows</p>

                <h2>Installation</h2>
                <pre><code class="language-bash">npm install @emmvish/stable-request</code></pre>
                
                <p><strong>Requirements:</strong> Node.js 14+ (ES Modules)</p>
            </section>

            <section id="core-functions" class="doc-section">
                <h2>Core Functions</h2>

                <h3 id="stable-request">stableRequest()</h3>
                    <p>Execute a single HTTP request with built-in retry logic, circuit breaker, caching, and observability hooks.</p>
                    
                    <h4>Signature</h4>
                    <pre><code class="language-typescript">function stableRequest&lt;RequestDataType = any, ResponseDataType = any&gt;(
  options: STABLE_REQUEST&lt;RequestDataType, ResponseDataType&gt;
): Promise&lt;ResponseDataType | false&gt;</code></pre>

                    <h4>Basic Usage</h4>
                    <pre><code class="language-typescript">import { stableRequest, RETRY_STRATEGIES, REQUEST_METHODS } from '@emmvish/stable-request';

const userData = await stableRequest({
  // Define the HTTP request configuration
  reqData: {
    hostname: 'api.example.com',              // Target API hostname
    path: '/users/123',                        // Endpoint path
    method: REQUEST_METHODS.GET,               // HTTP method
    headers: { 'Authorization': 'Bearer token' } // Custom headers
  },
  resReq: true,                               // Return the response data (not just true/false)
  attempts: 3,                                // Maximum retry attempts including initial request
  wait: 1000,                                 // Base wait time between retries (1 second)
  retryStrategy: RETRY_STRATEGIES.EXPONENTIAL, // Double wait time after each retry
  jitter: 500,                                // Add ±500ms randomness to prevent thundering herd
  
  // Custom response validation - return false to trigger retry
  responseAnalyzer: async ({ data }) => {
    return data.status === 'success';         // Only accept responses with success status
  },
  
  // Error handler called on each failed attempt
  handleErrors: async ({ errorLog }) => {
    console.error('Request failed:', errorLog);
  }
});</code></pre>

                    <h4>STABLE_REQUEST Interface</h4>
                    <p>Complete parameter reference for the <code>stableRequest</code> function options:</p>
                    <div class="table-wrapper">
                    <table class="params-table">
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th>Required</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>reqData</code></td>
                                <td><code>REQUEST_DATA&lt;RequestDataType&gt;</code></td>
                                <td>-</td>
                                <td>Yes</td>
                                <td>Request configuration including hostname, path, method, headers, body, query, timeout, protocol, port, signal</td>
                            </tr>
                            <tr>
                                <td><code>responseAnalyzer</code></td>
                                <td><code>(options: ResponseAnalysisHookOptions&lt;RequestDataType, ResponseDataType&gt;) =&gt; boolean | Promise&lt;boolean&gt;</code></td>
                                <td><code>() => true</code></td>
                                <td>No</td>
                                <td>Custom function to validate response content. Return <code>false</code> to trigger retry, <code>true</code> if response is acceptable</td>
                            </tr>
                            <tr>
                                <td><code>resReq</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, returns response data. If <code>false</code>, returns <code>true</code> on success or <code>false</code> on failure</td>
                            </tr>
                            <tr>
                                <td><code>attempts</code></td>
                                <td><code>number</code></td>
                                <td><code>1</code></td>
                                <td>No</td>
                                <td>Maximum number of attempts (including initial request). Must be ≥ 1</td>
                            </tr>
                            <tr>
                                <td><code>performAllAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, performs all attempts even if one succeeds (useful for testing)</td>
                            </tr>
                            <tr>
                                <td><code>wait</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Base wait time in milliseconds between retry attempts</td>
                            </tr>
                            <tr>
                                <td><code>maxAllowedWait</code></td>
                                <td><code>number</code></td>
                                <td><code>60000</code></td>
                                <td>No</td>
                                <td>Maximum allowed wait time between retries (caps the backoff calculation)</td>
                            </tr>
                            <tr>
                                <td><code>retryStrategy</code></td>
                                <td><code>RETRY_STRATEGY_TYPES</code></td>
                                <td><code>FIXED</code></td>
                                <td>No</td>
                                <td>Retry backoff strategy: <code>FIXED</code>, <code>LINEAR</code>, or <code>EXPONENTIAL</code></td>
                            </tr>
                            <tr>
                                <td><code>jitter</code></td>
                                <td><code>number</code></td>
                                <td><code>0</code></td>
                                <td>No</td>
                                <td>Random delay variation in milliseconds. If non-zero, applies randomized jitter to retry delays to prevent thundering herd</td>
                            </tr>
                            <tr>
                                <td><code>logAllErrors</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, logs all error attempts to console</td>
                            </tr>
                            <tr>
                                <td><code>handleErrors</code></td>
                                <td><code>(options: HandleErrorHookOptions&lt;RequestDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Custom error handler called for each failed attempt</td>
                            </tr>
                            <tr>
                                <td><code>logAllSuccessfulAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, logs all successful attempts to console</td>
                            </tr>
                            <tr>
                                <td><code>handleSuccessfulAttemptData</code></td>
                                <td><code>(options: HandleSuccessfulAttemptDataHookOptions&lt;RequestDataType, ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Custom handler called for each successful attempt</td>
                            </tr>
                            <tr>
                                <td><code>maxSerializableChars</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Maximum characters to include when serializing objects in logs</td>
                            </tr>
                            <tr>
                                <td><code>finalErrorAnalyzer</code></td>
                                <td><code>(options: FinalErrorAnalysisHookOptions&lt;RequestDataType&gt;) =&gt; boolean | Promise&lt;boolean&gt;</code></td>
                                <td><code>() => false</code></td>
                                <td>No</td>
                                <td>Analyzes the final error after all retries exhausted. Return <code>true</code> to suppress error (return <code>false</code>), <code>false</code> to throw</td>
                            </tr>
                            <tr>
                                <td><code>trialMode</code></td>
                                <td><code>TRIAL_MODE_OPTIONS</code></td>
                                <td><code>{ enabled: false }</code></td>
                                <td>No</td>
                                <td>Enables trial mode for testing without making real API calls. Configure failure probabilities and latency ranges</td>
                            </tr>
                            <tr>
                                <td><code>hookParams</code></td>
                                <td><code>HookParams</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Custom parameters to pass to hook functions (responseAnalyzerParams, handleErrorsParams, handleSuccessfulAttemptDataParams, finalErrorAnalyzerParams)</td>
                            </tr>
                            <tr>
                                <td><code>preExecution</code></td>
                                <td><code>RequestPreExecutionOptions</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Pre-execution hook configuration for dynamic request modification before execution</td>
                            </tr>
                            <tr>
                                <td><code>commonBuffer</code></td>
                                <td><code>Record&lt;string, any&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Shared buffer for storing/accessing data across requests, hooks, and workflow phases</td>
                            </tr>
                            <tr>
                                <td><code>cache</code></td>
                                <td><code>CacheConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Response caching configuration with TTL, cache control, status codes, and custom key generation</td>
                            </tr>
                            <tr>
                                <td><code>executionContext</code></td>
                                <td><code>ExecutionContext</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Execution context for logging and traceability (workflowId, phaseId, branchId, requestId)</td>
                            </tr>
                            <tr>
                                <td><code>circuitBreaker</code></td>
                                <td><code>CircuitBreakerConfig | CircuitBreaker</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Circuit breaker configuration or instance to prevent cascade failures and system overload</td>
                            </tr>
                            <tr>
                                <td><code>statePersistence</code></td>
                                <td><code>StatePersistenceConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>State persistence configuration for saving/loading workflow state to external storage (Redis, MongoDB, File System)</td>
                            </tr>
                        </tbody>
                    </table>
                    </div>

                <h3 id="stable-api-gateway">stableApiGateway()</h3>
                    <p>Execute multiple HTTP requests either sequentially or concurrently with unified configuration.</p>
                    
                    <h4>Signature</h4>
                    <pre><code class="language-typescript">function stableApiGateway&lt;RequestDataType = any, ResponseDataType = any&gt;(
  requests: API_GATEWAY_REQUEST&lt;RequestDataType, ResponseDataType&gt;[],
  options: API_GATEWAY_OPTIONS&lt;RequestDataType, ResponseDataType&gt;
): Promise&lt;API_GATEWAY_RESPONSE&lt;ResponseDataType&gt;[]&gt;</code></pre>

                    <h4>Concurrent Execution</h4>
                    <pre><code class="language-typescript">import { stableApiGateway } from '@emmvish/stable-request';

// Define multiple requests with unique IDs
const requests = [
  { id: 'users', requestOptions: { 
    reqData: { path: '/users' }, resReq: true 
  }},
  { id: 'orders', requestOptions: { 
    reqData: { path: '/orders' }, resReq: true 
  }},
  { id: 'products', requestOptions: { 
    reqData: { path: '/products' }, resReq: true 
  }}
];

const results = await stableApiGateway(requests, {
  concurrentExecution: true,         // Execute all requests simultaneously
  
  // Common configuration applied to all requests
  commonRequestData: { 
    hostname: 'api.example.com',     // Shared hostname
    headers: { 'X-API-Key': 'secret' } // Shared authentication
  },
  commonAttempts: 2,                 // Each request retries up to 2 times
  commonWait: 500,                   // 500ms wait between retries
  stopOnFirstError: false            // Continue executing even if some requests fail
});

// Process results - each result has the request ID and success status
results.forEach(result => {
  console.log(`${result.id}:`, result.success ? result.data : result.error);
});</code></pre>

                    <h4>Sequential Execution</h4>
                    <pre><code class="language-typescript">// Execute requests one at a time in order
const results = await stableApiGateway(requests, {
  concurrentExecution: false,    // Wait for each request to complete before starting next
  stopOnFirstError: true,        // Abort remaining requests if one fails
  commonRequestData: { hostname: 'api.example.com' },
  commonAttempts: 3              // Retry each request up to 3 times
});</code></pre>

                    <h4>Request Grouping</h4>
                    <p>Apply different configurations to groups of requests:</p>
                    <pre><code class="language-typescript">// Organize requests by assigning groupId to apply group-specific settings
const requests = [
  { id: 'critical-1', groupId: 'critical', requestOptions: { reqData: { path: '/critical/1' }, resReq: true } },
  { id: 'critical-2', groupId: 'critical', requestOptions: { reqData: { path: '/critical/2' }, resReq: true } },
  { id: 'optional-1', groupId: 'optional', requestOptions: { reqData: { path: '/optional/1' }, resReq: true } },
];

const results = await stableApiGateway(requests, {
  concurrentExecution: true,
  commonAttempts: 1,                                    // Default for requests without a group
  commonRequestData: { hostname: 'api.example.com' },
  
  // Define group-specific configurations
  requestGroups: [
    {
      id: 'critical',                                   // Matches groupId in requests
      commonConfig: {
        commonAttempts: 5,                              // Critical requests retry more
        commonWait: 1000,
        commonRetryStrategy: RETRY_STRATEGIES.EXPONENTIAL // Aggressive retry strategy
      }
    },
    {
      id: 'optional',                                   // Less critical requests
      commonConfig: {
        commonAttempts: 2,                              // Fewer retries for optional data
        commonWait: 500
      }
    }
  ]
});</code></pre>

                    <h4>API_GATEWAY_OPTIONS Interface</h4>
                    <p>Complete parameter reference for the <code>stableApiGateway</code> function options:</p>
                    <div class="table-wrapper">
                    <table class="params-table">
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th>Required</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>commonRequestData</code></td>
                                <td><code>Partial&lt;REQUEST_DATA&lt;RequestDataType&gt;&gt;</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Common request configuration applied to all requests (hostname, headers, protocol, etc.)</td>
                            </tr>
                            <tr>
                                <td><code>commonAttempts</code></td>
                                <td><code>number</code></td>
                                <td><code>1</code></td>
                                <td>No</td>
                                <td>Default number of retry attempts for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonHookParams</code></td>
                                <td><code>HookParams</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Default hook parameters for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonPerformAllAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default performAllAttempts setting for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonWait</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Default wait time between retries for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonMaxAllowedWait</code></td>
                                <td><code>number</code></td>
                                <td><code>60000</code></td>
                                <td>No</td>
                                <td>Default maximum wait time for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonRetryStrategy</code></td>
                                <td><code>RETRY_STRATEGY_TYPES</code></td>
                                <td><code>FIXED</code></td>
                                <td>No</td>
                                <td>Default retry strategy for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonJitter</code></td>
                                <td><code>number</code></td>
                                <td><code>0</code></td>
                                <td>No</td>
                                <td>Default jitter setting for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonLogAllErrors</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default error logging setting for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonLogAllSuccessfulAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default success logging setting for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonMaxSerializableChars</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Default max chars for serialization in logs</td>
                            </tr>
                            <tr>
                                <td><code>commonTrialMode</code></td>
                                <td><code>TRIAL_MODE_OPTIONS</code></td>
                                <td><code>{ enabled: false }</code></td>
                                <td>No</td>
                                <td>Default trial mode configuration for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonResponseAnalyzer</code></td>
                                <td><code>(options: ResponseAnalysisHookOptions&lt;RequestDataType, ResponseDataType&gt;) =&gt; boolean | Promise&lt;boolean&gt;</code></td>
                                <td><code>() => true</code></td>
                                <td>No</td>
                                <td>Default response analyzer for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonResReq</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default resReq value for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonFinalErrorAnalyzer</code></td>
                                <td><code>(options: FinalErrorAnalysisHookOptions&lt;RequestDataType&gt;) =&gt; boolean | Promise&lt;boolean&gt;</code></td>
                                <td><code>() => false</code></td>
                                <td>No</td>
                                <td>Default final error analyzer for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonHandleErrors</code></td>
                                <td><code>(options: HandleErrorHookOptions&lt;RequestDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Default error handler for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonHandleSuccessfulAttemptData</code></td>
                                <td><code>(options: HandleSuccessfulAttemptDataHookOptions&lt;RequestDataType, ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Default success handler for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonPreExecution</code></td>
                                <td><code>RequestPreExecutionOptions</code></td>
                                <td><code>() => {}</code></td>
                                <td>No</td>
                                <td>Default pre-execution hook configuration for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonCache</code></td>
                                <td><code>CacheConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Default cache configuration for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonStatePersistence</code></td>
                                <td><code>StatePersistenceConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Default state persistence configuration for all requests</td>
                            </tr>
                            <tr>
                                <td><code>concurrentExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>true</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, executes all requests concurrently. If <code>false</code>, executes sequentially</td>
                            </tr>
                            <tr>
                                <td><code>requestGroups</code></td>
                                <td><code>RequestGroup&lt;RequestDataType, ResponseDataType&gt;[]</code></td>
                                <td><code>[]</code></td>
                                <td>No</td>
                                <td>Array of request group configurations for applying settings to specific groups</td>
                            </tr>
                            <tr>
                                <td><code>stopOnFirstError</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, stops executing remaining requests after first error (sequential mode) or stops launching new requests (concurrent mode)</td>
                            </tr>
                            <tr>
                                <td><code>sharedBuffer</code></td>
                                <td><code>Record&lt;string, any&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Shared buffer accessible by all requests for data exchange</td>
                            </tr>
                            <tr>
                                <td><code>maxConcurrentRequests</code></td>
                                <td><code>number</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Maximum number of concurrent requests (concurrent mode only)</td>
                            </tr>
                            <tr>
                                <td><code>rateLimit</code></td>
                                <td><code>RateLimitConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Rate limiting configuration (maxRequests, windowMs)</td>
                            </tr>
                            <tr>
                                <td><code>circuitBreaker</code></td>
                                <td><code>CircuitBreakerConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Circuit breaker configuration shared across all requests</td>
                            </tr>
                            <tr>
                                <td><code>executionContext</code></td>
                                <td><code>Partial&lt;ExecutionContext&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Execution context for logging and traceability</td>
                            </tr>
                        </tbody>
                    </table>
                    </div>

                <h3 id="stable-workflow">stableWorkflow()</h3>
                    <p>Orchestrate complex multi-phase API workflows with support for sequential, concurrent, mixed, non-linear, and branching execution patterns.</p>
                    
                    <h4>Signature</h4>
                    <pre><code class="language-typescript">function stableWorkflow&lt;RequestDataType = any, ResponseDataType = any&gt;(
  phases: STABLE_WORKFLOW_PHASE&lt;RequestDataType, ResponseDataType&gt;[],
  options: STABLE_WORKFLOW_OPTIONS&lt;RequestDataType, ResponseDataType&gt;
): Promise&lt;STABLE_WORKFLOW_RESULT&lt;ResponseDataType&gt;&gt;</code></pre>

                    <h4>Basic Multi-Phase Workflow</h4>
                    <pre><code class="language-typescript">import { stableWorkflow, REQUEST_METHODS } from '@emmvish/stable-request';

// Define workflow as a sequence of phases
const phases = [
  {
    id: 'authentication',                           // Phase 1: Authenticate
    requests: [
      { 
        id: 'login', 
        requestOptions: { 
          reqData: { path: '/auth/login', method: REQUEST_METHODS.POST },
          resReq: true 
        }
      }
    ]
  },
  {
    id: 'fetch-data',                               // Phase 2: Fetch data (runs after auth)
    concurrentExecution: true,                      // Requests within this phase run in parallel
    requests: [
      { id: 'profile', requestOptions: { reqData: { path: '/profile' }, resReq: true }},
      { id: 'orders', requestOptions: { reqData: { path: '/orders' }, resReq: true }},
      { id: 'settings', requestOptions: { reqData: { path: '/settings' }, resReq: true }}
    ]
  },
  {
    id: 'process-data',                             // Phase 3: Process the fetched data
    requests: [
      { id: 'analytics', requestOptions: { 
        reqData: { path: '/analytics', method: REQUEST_METHODS.POST },
        resReq: false 
      }}
    ]
  }
];

const result = await stableWorkflow(phases, {
  workflowId: 'user-data-sync',                     // Unique workflow identifier
  commonRequestData: { hostname: 'api.example.com' }, // Shared config for all requests
  commonAttempts: 3,                                // Default retry attempts for all requests
  stopOnFirstPhaseError: true,                      // Stop workflow if any phase fails
  logPhaseResults: true                             // Log each phase completion
});

// Access workflow execution summary
console.log(`Workflow completed: ${result.success}`);
console.log(`Total requests: ${result.totalRequests}`);
console.log(`Successful: ${result.successfulRequests}`);
console.log(`Failed: ${result.failedRequests}`);
console.log(`Execution time: ${result.executionTime}ms`);</code></pre>

                    <h4>STABLE_WORKFLOW_PHASE Interface</h4>
                    <p>Complete parameter reference for defining individual workflow phases:</p>
                    <div class="table-wrapper">
                    <table class="params-table">
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th>Required</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>id</code></td>
                                <td><code>string</code></td>
                                <td><code>auto-generated</code></td>
                                <td>No</td>
                                <td>Unique identifier for the phase. Auto-generated if not provided</td>
                            </tr>
                            <tr>
                                <td><code>requests</code></td>
                                <td><code>API_GATEWAY_REQUEST[]</code></td>
                                <td>-</td>
                                <td>Yes</td>
                                <td>Array of requests to execute in this phase</td>
                            </tr>
                            <tr>
                                <td><code>concurrentExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, executes all requests in this phase concurrently. If <code>false</code>, executes sequentially</td>
                            </tr>
                            <tr>
                                <td><code>stopOnFirstError</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, stops executing remaining requests in this phase after first error</td>
                            </tr>
                            <tr>
                                <td><code>markConcurrentPhase</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Mark this phase for concurrent execution in mixed execution mode. Used with <code>enableMixedExecution</code></td>
                            </tr>
                            <tr>
                                <td><code>maxConcurrentRequests</code></td>
                                <td><code>number</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Maximum number of concurrent requests for this phase. Overrides workflow-level setting</td>
                            </tr>
                            <tr>
                                <td><code>rateLimit</code></td>
                                <td><code>RateLimitConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Rate limiting configuration for this phase. Overrides workflow-level setting</td>
                            </tr>
                            <tr>
                                <td><code>circuitBreaker</code></td>
                                <td><code>CircuitBreakerConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Circuit breaker configuration for this phase. Overrides workflow-level setting</td>
                            </tr>
                            <tr>
                                <td><code>maxReplayCount</code></td>
                                <td><code>number</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Maximum number of times this phase can be replayed in non-linear workflows</td>
                            </tr>
                            <tr>
                                <td><code>allowReplay</code></td>
                                <td><code>boolean</code></td>
                                <td><code>true</code></td>
                                <td>No</td>
                                <td>Whether this phase can be replayed via phase decision hook</td>
                            </tr>
                            <tr>
                                <td><code>allowSkip</code></td>
                                <td><code>boolean</code></td>
                                <td><code>true</code></td>
                                <td>No</td>
                                <td>Whether this phase can be skipped via phase decision hook</td>
                            </tr>
                            <tr>
                                <td><code>phaseDecisionHook</code></td>
                                <td><code>(options: PhaseDecisionHookOptions) =&gt; PhaseExecutionDecision | Promise&lt;PhaseExecutionDecision&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Hook function to determine what action to take after this phase completes. Used for non-linear workflows. Returns decision with action: CONTINUE, SKIP, JUMP, REPLAY, or TERMINATE</td>
                            </tr>
                            <tr>
                                <td><code>commonConfig</code></td>
                                <td><code>Partial&lt;API_GATEWAY_OPTIONS&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Phase-level configuration containing all <code>common*</code> properties from API_GATEWAY_OPTIONS interface (e.g., commonAttempts, commonWait, commonRetryStrategy, commonRequestData, etc.). These settings apply to all requests in this phase and override workflow-level common settings</td>
                            </tr>
                            <tr>
                                <td><code>branchId</code></td>
                                <td><code>string</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Branch identifier when this phase is part of a branched workflow</td>
                            </tr>
                            <tr>
                                <td><code>statePersistence</code></td>
                                <td><code>StatePersistenceConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>State persistence configuration for this phase. Allows saving/loading phase state to external storage</td>
                            </tr>
                        </tbody>
                    </table>
                    </div>

                    <h4>STABLE_WORKFLOW_OPTIONS Interface</h4>
                    <p>Complete parameter reference for the <code>stableWorkflow</code> function options. Extends all <code>API_GATEWAY_OPTIONS</code> plus workflow-specific parameters:</p>
                    <div class="table-wrapper">
                    <table class="params-table">
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th>Required</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>workflowId</code></td>
                                <td><code>string</code></td>
                                <td><code>'workflow-{timestamp}'</code></td>
                                <td>No</td>
                                <td>Unique identifier for this workflow execution</td>
                            </tr>
                            <tr>
                                <td><code>stopOnFirstPhaseError</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, stops workflow execution after first phase error</td>
                            </tr>
                            <tr>
                                <td><code>logPhaseResults</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, logs each phase result to console</td>
                            </tr>
                            <tr>
                                <td><code>concurrentPhaseExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, all phases execute concurrently. If <code>false</code>, phases execute sequentially</td>
                            </tr>
                            <tr>
                                <td><code>enableBranchExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Enables branch-based workflow execution with independent branches</td>
                            </tr>
                            <tr>
                                <td><code>branches</code></td>
                                <td><code>STABLE_WORKFLOW_BRANCH&lt;RequestDataType, ResponseDataType&gt;[]</code></td>
                                <td><code>[]</code></td>
                                <td>No</td>
                                <td>Array of workflow branches (when enableBranchExecution is true)</td>
                            </tr>
                            <tr>
                                <td><code>enableMixedExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Enables mixed execution mode where phases can be marked for concurrent execution using markConcurrentPhase</td>
                            </tr>
                            <tr>
                                <td><code>enableNonLinearExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Enables non-linear execution with phase decision hooks (JUMP, SKIP, REPLAY, TERMINATE)</td>
                            </tr>
                            <tr>
                                <td><code>maxWorkflowIterations</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Maximum total phase executions to prevent infinite loops in non-linear workflows</td>
                            </tr>
                            <tr>
                                <td><code>statePersistence</code></td>
                                <td><code>StatePersistenceConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>State persistence configuration for workflow recovery and distributed execution</td>
                            </tr>
                            <tr>
                                <td><code>handlePhaseCompletion</code></td>
                                <td><code>(options: HandlePhaseCompletionHookOptions&lt;ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Hook called after each phase completes successfully. Receives workflowId, branchId, phaseResult, params, sharedBuffer</td>
                            </tr>
                            <tr>
                                <td><code>handlePhaseError</code></td>
                                <td><code>(options: HandlePhaseErrorHookOptions&lt;ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Hook called when a phase encounters an error</td>
                            </tr>
                            <tr>
                                <td><code>handlePhaseDecision</code></td>
                                <td><code>(options: HandlePhaseDecisionHookOptions&lt;ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => {}</code></td>
                                <td>No</td>
                                <td>Hook called when a phase makes a non-linear decision (JUMP, SKIP, REPLAY, TERMINATE)</td>
                            </tr>
                            <tr>
                                <td><code>handleBranchCompletion</code></td>
                                <td><code>(options: {workflowId, branchId, branchResults, success}) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Hook called when a branch completes. Receives workflowId, branchId, branchResults, success</td>
                            </tr>
                            <tr>
                                <td><code>handleBranchDecision</code></td>
                                <td><code>(decision: BranchExecutionDecision, branchResult: BranchExecutionResult&lt;ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => {}</code></td>
                                <td>No</td>
                                <td>Hook called when a branch makes a decision</td>
                            </tr>
                            <tr>
                                <td><code>maxSerializableChars</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Maximum characters for serialization in logs</td>
                            </tr>
                            <tr>
                                <td><code>workflowHookParams</code></td>
                                <td><code>WorkflowHookParams</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Custom parameters passed to workflow-level hooks (handlePhaseCompletionParams, handlePhaseErrorParams, handlePhaseDecisionParams, handleBranchDecisionParams)</td>
                            </tr>
                            <tr>
                                <td><code>commonRequestData</code></td>
                                <td><code>Partial&lt;REQUEST_DATA&gt;</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Common request configuration applied to all phases</td>
                            </tr>
                            <tr>
                                <td><code>commonAttempts</code></td>
                                <td><code>number</code></td>
                                <td><code>1</code></td>
                                <td>No</td>
                                <td>Default retry attempts for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonWait</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Default wait time between retries</td>
                            </tr>
                            <tr>
                                <td><code>commonRetryStrategy</code></td>
                                <td><code>RETRY_STRATEGY_TYPES</code></td>
                                <td><code>FIXED</code></td>
                                <td>No</td>
                                <td>Default retry strategy</td>
                            </tr>
                            <tr>
                                <td><code>commonCache</code></td>
                                <td><code>CacheConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Default cache configuration</td>
                            </tr>
                            <tr>
                                <td><code>commonStatePersistence</code></td>
                                <td><code>StatePersistenceConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Default state persistence for all phases</td>
                            </tr>
                            <tr>
                                <td><code>circuitBreaker</code></td>
                                <td><code>CircuitBreakerConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Circuit breaker shared across workflow</td>
                            </tr>
                            <tr>
                                <td><code>rateLimit</code></td>
                                <td><code>RateLimitConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Rate limiting configuration</td>
                            </tr>
                            <tr>
                                <td><code>maxConcurrentRequests</code></td>
                                <td><code>number</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Maximum concurrent requests</td>
                            </tr>
                            <tr>
                                <td><code>sharedBuffer</code></td>
                                <td><code>Record&lt;string, any&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Shared buffer for data exchange across phases</td>
                            </tr>
                            <tr>
                                <td><code>requestGroups</code></td>
                                <td><code>RequestGroup[]</code></td>
                                <td><code>[]</code></td>
                                <td>No</td>
                                <td>Request group configurations</td>
                            </tr>
                            <tr>
                                <td><code>commonHookParams</code></td>
                                <td><code>HookParams</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Default hook parameters</td>
                            </tr>
                            <tr>
                                <td><code>commonPerformAllAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default performAllAttempts setting</td>
                            </tr>
                            <tr>
                                <td><code>commonMaxAllowedWait</code></td>
                                <td><code>number</code></td>
                                <td><code>60000</code></td>
                                <td>No</td>
                                <td>Default maximum wait time</td>
                            </tr>
                            <tr>
                                <td><code>commonJitter</code></td>
                                <td><code>number</code></td>
                                <td><code>0</code></td>
                                <td>No</td>
                                <td>Default jitter setting</td>
                            </tr>
                            <tr>
                                <td><code>commonLogAllErrors</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default error logging</td>
                            </tr>
                            <tr>
                                <td><code>commonLogAllSuccessfulAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default success logging</td>
                            </tr>
                            <tr>
                                <td><code>commonMaxSerializableChars</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Default max serialization chars</td>
                            </tr>
                            <tr>
                                <td><code>commonTrialMode</code></td>
                                <td><code>TRIAL_MODE_OPTIONS</code></td>
                                <td><code>{ enabled: false }</code></td>
                                <td>No</td>
                                <td>Default trial mode</td>
                            </tr>
                            <tr>
                                <td><code>commonResponseAnalyzer</code></td>
                                <td><code>Function</code></td>
                                <td><code>() => true</code></td>
                                <td>No</td>
                                <td>Default response analyzer</td>
                            </tr>
                            <tr>
                                <td><code>commonResReq</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default resReq value</td>
                            </tr>
                            <tr>
                                <td><code>commonFinalErrorAnalyzer</code></td>
                                <td><code>Function</code></td>
                                <td><code>() => false</code></td>
                                <td>No</td>
                                <td>Default final error analyzer</td>
                            </tr>
                            <tr>
                                <td><code>commonHandleErrors</code></td>
                                <td><code>Function</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Default error handler</td>
                            </tr>
                            <tr>
                                <td><code>commonHandleSuccessfulAttemptData</code></td>
                                <td><code>Function</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Default success handler</td>
                            </tr>
                            <tr>
                                <td><code>commonPreExecution</code></td>
                                <td><code>RequestPreExecutionOptions</code></td>
                                <td><code>() => {}</code></td>
                                <td>No</td>
                                <td>Default pre-execution hook</td>
                            </tr>
                            <tr>
                                <td><code>executionContext</code></td>
                                <td><code>Partial&lt;ExecutionContext&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Execution context for logging</td>
                            </tr>
                        </tbody>
                    </table>
                    </div>
            </section>

            <section id="config-cascading" class="doc-section">
                <h2>Configuration Cascading</h2>
                <p>Understand how configuration options cascade and override from higher levels to lower levels, allowing you to set defaults globally while customizing specific requests.</p>

                <h3>Cascading Principles</h3>
                <p>Configuration follows a hierarchical override pattern where:</p>
                <ul>
                    <li><strong>Lower-level configurations override higher-level ones</strong></li>
                    <li><strong>More specific settings take precedence over general settings</strong></li>
                    <li><strong>Request-level options always have the highest priority</strong></li>
                </ul>

                <h3 id="api-gateway-cascading">API Gateway Configuration Cascading</h3>
                <p>In <code>stableApiGateway</code>, configuration flows from gateway options to individual requests:</p>
                
                <div class="hierarchy-diagram">
                    <pre><code class="language-text">Gateway Options (common*)
    ↓
Request Group Options (for matching groupId)
    ↓
Individual Request Options
    ↓
<strong>Final Configuration Applied</strong></code></pre>
                </div>

                <h4>Cascading Hierarchy</h4>
                <ol>
                    <li><strong>Gateway-Level (Lowest Priority):</strong> <code>common*</code> options apply to all requests
                        <ul>
                            <li><code>commonRequestData</code> - Shared request configuration (hostname, headers, etc.)</li>
                            <li><code>commonAttempts</code> - Default retry attempts</li>
                            <li><code>commonWait</code> - Default wait time between retries</li>
                            <li><code>commonRetryStrategy</code> - Default retry strategy</li>
                            <li><code>commonJitter</code> - Default jitter setting</li>
                            <li>And all other <code>common*</code> properties...</li>
                        </ul>
                    </li>
                    <li><strong>Request Group-Level (Medium Priority):</strong> Settings for specific request groups override gateway defaults</li>
                    <li><strong>Request-Level (Highest Priority):</strong> Individual request options override all others</li>
                </ol>

                <h4>Example: API Gateway Cascading</h4>
                <pre><code class="language-typescript">const requests = [
  { 
    id: 'user-1', 
    groupId: 'critical',                            // Belongs to 'critical' group
    requestOptions: { 
      reqData: { path: '/users/1' },
      attempts: 7,                                  // Request-level: Highest priority
      resReq: true
    }
  },
  { 
    id: 'user-2', 
    groupId: 'critical',                            // Uses group settings
    requestOptions: { 
      reqData: { path: '/users/2' },
      resReq: true                                  // Will use group's 5 attempts
    }
  },
  { 
    id: 'analytics', 
    groupId: 'optional',                            // Belongs to 'optional' group
    requestOptions: { 
      reqData: { path: '/analytics' },
      resReq: true                                  // Will use group's 1 attempt
    }
  },
  { 
    id: 'logs',                                     // No groupId assigned
    requestOptions: { 
      reqData: { path: '/logs' },
      resReq: true                                  // Will use gateway's 3 attempts
    }
  }
];

await stableApiGateway(requests, {
  // Gateway-Level (applies to all) - Lowest priority
  commonRequestData: { 
    hostname: 'api.example.com',
    headers: { 'X-API-Key': 'secret' }
  },
  commonAttempts: 3,                                // Default for all
  commonWait: 1000,
  commonRetryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
  
  // Request Group-Level (overrides gateway defaults) - Medium priority
  requestGroups: [
    {
      id: 'critical',
      commonConfig: {
        commonAttempts: 5,                          // Critical requests: 5 attempts
        commonWait: 2000                            // Longer wait for critical data
      }
    },
    {
      id: 'optional',
      commonConfig: {
        commonAttempts: 1,                          // Optional requests: single attempt
        commonWait: 500                             // Shorter wait for non-critical data
      }
    }
  ]
});

// Final Configuration Applied (showing precedence):
// user-1:     7 attempts, 1000ms wait (request-level attempts, gateway wait)
// user-2:     5 attempts, 2000ms wait (group-level overrides)
// analytics:  1 attempt,  500ms wait  (group-level overrides)
// logs:       3 attempts, 1000ms wait (gateway-level defaults)</code></pre>

                <h3 id="workflow-cascading">Workflow Configuration Cascading</h3>
                <p>In <code>stableWorkflow</code>, configuration flows through multiple layers:</p>
                
                <div class="hierarchy-diagram">
                    <pre><code class="language-text">Workflow Options (common*)
    ↓
Branch Configuration (in branched workflows)
    ↓
Phase Configuration (commonConfig property)
    ↓
Request Group Options (for matching groupId)
    ↓
Individual Request Options
    ↓
<strong>Final Configuration Applied</strong></code></pre>
                </div>

                <h4>Cascading Hierarchy</h4>
                <ol>
                    <li><strong>Workflow-Level (Lowest Priority):</strong> <code>common*</code> options in workflow options apply to all phases and requests</li>
                    <li><strong>Branch-Level:</strong> In branched workflows, branch configuration overrides workflow defaults</li>
                    <li><strong>Phase-Level:</strong> Phase <code>commonConfig</code> property overrides workflow/branch settings for that phase</li>
                    <li><strong>Request Group-Level:</strong> Request group settings override phase/workflow defaults</li>
                    <li><strong>Request-Level (Highest Priority):</strong> Individual request options override all others</li>
                </ol>

                <h4>Example: Workflow Cascading</h4>
                <pre><code class="language-typescript">const phases = [
  {
    id: 'critical-phase',
    requests: [
      { 
        id: 'auth', 
        requestOptions: { 
          reqData: { path: '/auth' },
          attempts: 10,                             // Request-level: Highest priority
          resReq: true
        }
      },
      { 
        id: 'validate', 
        requestOptions: { 
          reqData: { path: '/validate' },
          resReq: true                              // Uses phase-level: 7 attempts
        }
      }
    ],
    // Phase-Level Configuration (overrides workflow defaults)
    commonConfig: {
      commonAttempts: 7,                            // Critical phase gets more retries
      commonWait: 3000,
      commonRetryStrategy: RETRY_STRATEGIES.EXPONENTIAL
    }
  },
  {
    id: 'data-fetch',
    concurrentExecution: true,                      // Requests run in parallel
    requests: [
      { 
        id: 'users', 
        groupId: 'important',                       // Belongs to 'important' group
        requestOptions: { 
          reqData: { path: '/users' },
          resReq: true                              // Uses group-level: 5 attempts
        }
      },
      { 
        id: 'products', 
        requestOptions: { 
          reqData: { path: '/products' },
          resReq: true                              // Uses workflow-level: 3 attempts
        }
      }
    ]
  }
];

await stableWorkflow(phases, {
  workflowId: 'config-cascade-demo',
  
  // Workflow-Level (applies to all phases) - Lowest priority
  commonRequestData: { 
    hostname: 'api.example.com',
    headers: { 'Authorization': 'Bearer token' }
  },
  commonAttempts: 3,                                // Default for all requests
  commonWait: 1000,
  commonRetryStrategy: RETRY_STRATEGIES.LINEAR,
  
  // Request Group-Level (overrides workflow defaults)
  requestGroups: [
    {
      id: 'important',
      commonConfig: {
        commonAttempts: 5,                          // Important requests: more retries
        commonWait: 2000
      }
    }
  ]
});

// Final Configuration Applied (showing precedence chain):
// auth:     10 attempts, 3000ms wait (request > phase)
// validate: 7 attempts,  3000ms wait (phase > workflow)
// users:    5 attempts,  2000ms wait (group > workflow)
// products: 3 attempts,  1000ms wait (workflow defaults)</code></pre>

                <h4>Example: Branched Workflow Cascading</h4>
                <pre><code class="language-typescript">const branches = [
  {
    id: 'payment-branch',
    phases: [
      {
        id: 'authorize',
        requests: [
          { 
            id: 'check-funds', 
            requestOptions: { 
              reqData: { path: '/payment/authorize' },
              attempts: 8,                          // Request-level: Highest priority
              resReq: true
            }
          }
        ],
        commonConfig: {
          commonAttempts: 6,                        // Phase-level overrides branch
          commonWait: 2000
        }
      }
    ],
    commonConfig: {
      commonAttempts: 4,                            // Branch-level overrides workflow
      commonWait: 1500
    }
  },
  {
    id: 'notification-branch',
    phases: [
      {
        id: 'send-email',
        requests: [
          { 
            id: 'email', 
            requestOptions: { 
              reqData: { path: '/notify/email' },
              resReq: true                          // Uses branch-level: 2 attempts
            }
          }
        ]
      }
    ],
    commonConfig: {
      commonAttempts: 2,                            // Branch-level for notifications
      commonWait: 500
    }
  }
];

await stableWorkflow([], {
  workflowId: 'branched-cascade',
  enableBranchExecution: true,                      // Enable branched workflow mode
  branches,
  
  // Workflow-Level (applies to all branches) - Lowest priority
  commonAttempts: 3,
  commonWait: 1000,
  commonRequestData: { 
    hostname: 'api.example.com' 
  }
});

// Final Configuration Applied (5-level precedence):
// check-funds: 8 attempts, 2000ms wait (request > phase > branch > workflow)
// email:       2 attempts, 500ms wait  (branch > workflow)</code></pre>

                <h3>Configuration Precedence Rules</h3>
                <p>When the same configuration property is defined at multiple levels:</p>
                
                <h4>API Gateway Priority (High to Low)</h4>
                <pre><code class="language-text">Request Options
    ↓
Request Group Options
    ↓
Gateway common* Options</code></pre>

                <h4>Workflow Priority (High to Low)</h4>
                <pre><code class="language-text">Request Options
    ↓
Request Group Options
    ↓
Phase commonConfig
    ↓
Branch commonConfig (in branched workflows)
    ↓
Workflow common* Options</code></pre>
            </section>

            <section id="state-buffers" class="doc-section">
                <h2>State Buffers</h2>
                <h3>Overview</h3>
                <p>Buffers provide a mechanism for sharing data across different parts of your workflows without relying on global variables. There are two types of buffers:</p>
                <ul>
                    <li><strong>commonBuffer</strong> - Request-level buffer for individual requests in <code>stableRequest</code></li>
                    <li><strong>sharedBuffer</strong> - Gateway/Workflow-level buffer shared across all requests in <code>stableApiGateway</code> and <code>stableWorkflow</code></li>
                </ul>

                <h3>The Override Rule</h3>
                <p class="highlight-box"><strong>Important:</strong> When both <code>commonBuffer</code> and <code>sharedBuffer</code> are present, <code>sharedBuffer</code> takes precedence and completely overrides <code>commonBuffer</code> for that execution context.</p>

                <h3>commonBuffer - Request-Level State</h3>
                <p>Used in <code>stableRequest</code> to maintain state across retry attempts and hooks for a single request.</p>

                <h4>Use Cases</h4>
                <ul>
                    <li>Store authentication tokens obtained during pre-execution</li>
                    <li>Track retry-specific metadata</li>
                    <li>Pass data between request hooks (preExecution, responseAnalyzer, handleErrors)</li>
                    <li>Accumulate information across multiple retry attempts</li>
                </ul>

                <h4>Example: Using commonBuffer</h4>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { 
    hostname: 'api.example.com', 
    path: '/protected-resource' 
  },
  resReq: true,
  attempts: 3,
  
  // Initialize buffer with tracking state
  commonBuffer: {
    attemptCount: 0,                                // Track retry attempts
    authToken: null,                                // Store auth token across retries
    errors: []                                      // Accumulate error history
  },
  
  // Pre-execution: Modify request based on buffer state
  preExecution: {
    preExecutionHook: async ({ inputParams, commonBuffer }) => {
      // Access and modify the buffer (shared across all hooks and retries)
      commonBuffer.attemptCount++;
      
      // Add dynamic authentication if not already present
      if (!commonBuffer.authToken) {
        commonBuffer.authToken = await getAuthToken();
      }
      
      // Inject auth token and attempt count into request
      const reqData = {
        ...inputParams.reqData,
        headers: {
          'Authorization': `Bearer ${commonBuffer.authToken}`,
          'X-Attempt': commonBuffer.attemptCount.toString()
        }
      };
      
      return { reqData };                           // Return modified request data
    }
  },
  
  // Response analyzer: Use buffer to detect and handle auth expiry
  responseAnalyzer: async ({ data, status, commonBuffer }) => {
    if (status === 401) {
      // Auth token expired, clear it for retry (will re-fetch in preExecution)
      delete commonBuffer.authToken;
      return false;                                 // Trigger retry
    }
    return true;                                    // Success - accept response
  },
  
  // Error handler: Accumulate error history in buffer for debugging
  handleErrors: async ({ error, commonBuffer, attempt }) => {
    commonBuffer.errors.push({
      attempt,
      error: error.message,
      timestamp: new Date().toISOString()
    });
    console.log(`Error history:`, commonBuffer.errors);
  }
});</code></pre>

                <h3>sharedBuffer - Gateway/Workflow-Level State</h3>
                <p>Used in <code>stableApiGateway</code> and <code>stableWorkflow</code> to share state across multiple requests and phases.</p>

                <h4>Use Cases</h4>
                <ul>
                    <li>Share authentication tokens across all requests</li>
                    <li>Pass data from one phase to another in workflows</li>
                    <li>Accumulate results across multiple requests</li>
                    <li>Implement workflow-level state machines</li>
                    <li>Track global metrics (total processed items, errors, etc.)</li>
                    <li>Store checkpoint data for workflow resumption</li>
                </ul>

                <h4>Example: API Gateway with sharedBuffer</h4>
                <pre><code class="language-typescript">const requests = [
  {
    id: 'login',
    requestOptions: {
      reqData: { 
        hostname: 'api.example.com',
        path: '/auth/login',
        method: REQUEST_METHODS.POST,
        body: { username: 'user', password: 'pass' }
      },
      resReq: true                                  // Expect response data
    }
  },
  {
    id: 'get-profile',
    requestOptions: {
      reqData: { 
        hostname: 'api.example.com',
        path: '/user/profile'
      },
      resReq: true,
      preExecution: {
        preExecutionHook: async ({ inputParams, commonBuffer }) => {
          // Use token from previous 'login' request (stored in sharedBuffer)
          const reqData = {
            ...inputParams.reqData,
            headers: {
              'Authorization': `Bearer ${commonBuffer.authToken}`
            }
          };
          return { reqData };                       // Return modified request with auth
        }
      }
    }
  },
  {
    id: 'get-orders',
    requestOptions: {
      reqData: { 
        hostname: 'api.example.com',
        path: '/user/orders'
      },
      resReq: true,
      preExecution: {
        preExecutionHook: async ({ inputParams, commonBuffer }) => {
          // Reuse same token from sharedBuffer
          const reqData = {
            ...inputParams.reqData,
            headers: {
              'Authorization': `Bearer ${commonBuffer.authToken}`
            }
          };
          return { reqData };
        }
      }
    }
  }
];

await stableApiGateway(requests, {
  concurrentExecution: false,                       // Sequential: login must complete first
  
  // commonBuffer is accessible to ALL requests in the gateway
  commonBuffer: {
    authToken: null,                                // Will be populated by login request
    userProfile: null,                              // Will be populated by profile request
    totalOrders: 0                                  // Will be populated by orders request
  },
  
  // Common success handler: runs after each successful request
  commonHandleSuccessfulAttemptData: async ({ data, commonBuffer, executionContext }) => {
    if (executionContext.requestId === 'login') {
      commonBuffer.authToken = data.token;          // Store token for subsequent requests
      console.log('Auth token stored in commonBuffer');
    } else if (executionContext.requestId === 'get-profile') {
      commonBuffer.userProfile = data;              // Store profile data
    } else if (executionContext.requestId === 'get-orders') {
      commonBuffer.totalOrders = data.length;       // Store order count
    }
  }
});

// After execution, commonBuffer contains all accumulated data
console.log('Total orders:', sharedBuffer.totalOrders);</code></pre>

                <h4>Example: Workflow with sharedBuffer</h4>
                <pre><code class="language-typescript">const phases = [
  {
    id: 'authentication',
    requests: [{
      id: 'auth',
      requestOptions: {
        reqData: { 
          hostname: 'api.example.com',
          path: '/auth/login',
          method: REQUEST_METHODS.POST,
          body: { username: 'user', password: 'pass' }
        },
        resReq: true                                // Expect auth token in response
      }
    }]
  },
  {
    id: 'fetch-data',
    concurrentExecution: true,                      // Parallel execution for efficiency
    requests: [
      { 
        id: 'users', 
        requestOptions: { 
          reqData: { path: '/users' },
          resReq: true,
          preExecution: {
            preExecutionHook: async ({ inputParams, commonBuffer }) => {
              // Use token from Phase 1 (stored in sharedBuffer)
              const reqData = {
                ...inputParams.reqData,
                headers: {
                  'Authorization': `Bearer ${commonBuffer.authToken}`
                }
              };
              return { reqData };
            }
          }
        }
      },
      { 
        id: 'products', 
        requestOptions: { 
          reqData: { path: '/products' },
          resReq: true,
          preExecution: {
            preExecutionHook: async ({ inputParams, commonBuffer }) => {
              // Same token shared across all Phase 2 requests
              const reqData = {
                ...inputParams.reqData,
                headers: {
                  'Authorization': `Bearer ${commonBuffer.authToken}`
                }
              };
              return { reqData };
            }
          }
        }
      }
    ]
  },
  {
    id: 'process',
    requests: [{
      id: 'analytics',
      requestOptions: {
        reqData: { 
          path: '/analytics',
          method: REQUEST_METHODS.POST,
          body: {}                                  // Will be populated with Phase 2 data
        },
        resReq: false,
        preExecution: {
          preExecutionHook: async ({ inputParams, commonBuffer }) => {
            // Use accumulated data from previous phases
            const reqData = {
              ...inputParams.reqData,
              body: {
                userCount: commonBuffer.users?.length || 0,
                productCount: commonBuffer.products?.length || 0
              },
              headers: {
                'Authorization': `Bearer ${commonBuffer.authToken}`
              }
            };
            return { reqData };
          }
        }
      }
    }]
  }
];

await stableWorkflow(phases, {
  workflowId: 'data-sync',
  commonRequestData: { hostname: 'api.example.com' },
  
  // sharedBuffer accessible across ALL phases (persists throughout workflow)
  sharedBuffer: {
    authToken: null,                                // Populated in Phase 1
    users: [],                                      // Populated in Phase 2
    products: []                                    // Populated in Phase 2
  },
  
  // Store successful response data in sharedBuffer after each phase
  handlePhaseCompletion: async ({ phaseResult, sharedBuffer }) => {
    if (phaseResult.phaseId === 'authentication') {
      const authResponse = phaseResult.responses.find(r => r.requestId === 'auth');
      if (authResponse?.success) {
        sharedBuffer.authToken = authResponse.data.token; // Store for Phase 2 & 3
      }
    } else if (phaseResult.phaseId === 'fetch-data') {
      phaseResult.responses.forEach(response => {
        if (response.requestId === 'users' && response.success) {
          sharedBuffer.users = response.data;       // Store for Phase 3
        } else if (response.requestId === 'products' && response.success) {
          sharedBuffer.products = response.data;    // Store for Phase 3
        }
      });
    }
  }
});</code></pre>

                <h3>Override Behavior: sharedBuffer vs commonBuffer</h3>
                <p>When a request has both <code>commonBuffer</code> in its options and is executed within a context that provides <code>sharedBuffer</code> (API Gateway or Workflow), the <code>sharedBuffer</code> completely replaces <code>commonBuffer</code>.</p>

                <h4>Example: Understanding the Override</h4>
                <pre><code class="language-typescript">const requests = [
  {
    id: 'request-1',
    requestOptions: {
      reqData: { hostname: 'api.example.com', path: '/data1' },
      resReq: true,
      
      // This commonBuffer will be IGNORED (overridden by gateway's sharedBuffer)
      commonBuffer: {
        source: 'request-level',
        value: 'ignored'
      },
      
      preExecution: {
        preExecutionHook: async ({ inputParams, commonBuffer }) => {
          // commonBuffer parameter actually refers to gateway's commonBuffer
          console.log(commonBuffer.source); // Outputs: 'gateway-level'
          console.log(commonBuffer.value);  // Outputs: 'active'
          
          // Modifications affect the gateway's commonBuffer (shared across all requests)
          commonBuffer.modifiedBy = 'request-1';
          return { reqData: inputParams.reqData };
        }
      }
    }
  },
  {
    id: 'request-2',
    requestOptions: {
      reqData: { hostname: 'api.example.com', path: '/data2' },
      resReq: true,
      preExecution: {
        preExecutionHook: async ({ inputParams, commonBuffer }) => {
          // Can see modifications from request-1 (same sharedBuffer reference)
          console.log(commonBuffer.modifiedBy); // Outputs: 'request-1'
          return { reqData: inputParams.reqData };
        }
      }
    }
  }
];

await stableApiGateway(requests, {
  concurrentExecution: false,
  
  // This sharedBuffer OVERRIDES all request-level commonBuffers
  sharedBuffer: {
    source: 'gateway-level',
    value: 'active'
  }
});

// Override Rule: sharedBuffer (gateway/workflow level) > commonBuffer (request level)</code></pre>

                <h4>Standalone Request vs Gateway Context</h4>
                <pre><code class="language-typescript">// Scenario 1: Standalone stableRequest - commonBuffer is used
await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  resReq: true,
  commonBuffer: { 
    mode: 'standalone',
    counter: 0 
  },
  preExecution: {
    preExecutionHook: async ({ inputParams, commonBuffer }) => {
      // commonBuffer refers to commonBuffer in this context
      console.log(commonBuffer.mode); // 'standalone'
      commonBuffer.counter++;
      return { reqData: inputParams.reqData };
    }
  }
});

// Scenario 2: Same request config in API Gateway - sharedBuffer overrides
await stableApiGateway([{
  id: 'req1',
  requestOptions: {
    reqData: { hostname: 'api.example.com', path: '/data' },
    resReq: true,
    commonBuffer: { 
      mode: 'standalone',  // IGNORED
      counter: 0           // IGNORED
    },
    preExecution: {
      preExecutionHook: async ({ inputParams, commonBuffer }) => {
        // commonBuffer refers to gateway's sharedBuffer
        console.log(commonBuffer.mode); // 'gateway'
        commonBuffer.counter++;
        return { reqData: inputParams.reqData };
      }
    }
  }
}], {
  sharedBuffer: {
    mode: 'gateway',
    counter: 100  // This is what gets used
  }
});</code></pre>
            </section>

            <section id="retry-strategies" class="doc-section">
                <h2>Retry Strategies</h2>
                <p>Automatically retry failed requests with sophisticated backoff strategies.</p>

                <h3>Fixed Delay</h3>
                <p>Constant wait time between each retry attempt.</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  attempts: 5,                                      // Try up to 5 times
  wait: 1000,                                       // Wait timing: 1s, 1s, 1s, 1s (constant)
  retryStrategy: RETRY_STRATEGIES.FIXED             // Same delay between each retry
});</code></pre>

                <h3>Linear Backoff</h3>
                <p>Incrementally increasing delays.</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  attempts: 5,
  wait: 1000,                                       // Wait timing: 1s, 2s, 3s, 4s (linear growth)
  retryStrategy: RETRY_STRATEGIES.LINEAR            // Delay increases by 'wait' each retry
});</code></pre>

                <h3>Exponential Backoff</h3>
                <p>Exponentially growing delays (recommended for most use cases).</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  attempts: 5,
  wait: 1000,                                       // Wait timing: 1s, 2s, 4s, 8s, 16s (exponential)
  retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,      // Delay doubles each retry
  maxAllowedWait: 30000                             // Cap maximum delay at 30 seconds
});</code></pre>

                <h3>Jitter</h3>
                <p>Add randomness to prevent thundering herd problems.</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  attempts: 5,
  wait: 1000,
  retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
  jitter: 500                                       // Add ±500ms random variation to each wait
});</code></pre>                                          // Prevents all clients retrying at same time

                <h3>Custom Response Validation</h3>
                <p>Retry based on response content, not just HTTP status.</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/job/status' },
  resReq: true,
  attempts: 10,                                     // Poll up to 10 times
  wait: 2000,                                       // Wait 2s between polls
  responseAnalyzer: async ({ data }) => {
    // Retry (return false) until job is complete
    return data.status === 'completed';             // Return true to accept response
  }
});</code></pre>
            </section>

            <section id="circuit-breaker" class="doc-section">
                <h2>Circuit Breaker Pattern</h2>
                <p>Prevent cascade failures and system overload with built-in circuit breakers.</p>

                <h3>Circuit Breaker States</h3>
                <ul>
                    <li><strong>CLOSED:</strong> Normal operation, requests flow through</li>
                    <li><strong>OPEN:</strong> Too many failures detected, requests blocked immediately</li>
                    <li><strong>HALF_OPEN:</strong> Testing if service recovered, limited requests allowed</li>
                </ul>

                <h3>Basic Usage with API Gateway</h3>
                <pre><code class="language-typescript">import { stableApiGateway } from '@emmvish/stable-request';

const requests = [
  { id: 'req1', requestOptions: { reqData: { path: '/users' }, resReq: true, attempts: 3 } },
  { id: 'req2', requestOptions: { reqData: { path: '/orders' }, resReq: true, attempts: 3 } },
  { id: 'req3', requestOptions: { reqData: { path: '/products' }, resReq: true, attempts: 3 } }
];

await stableApiGateway(requests, {
  commonRequestData: { hostname: 'unreliable-api.example.com' },
  circuitBreaker: {
    failureThresholdPercentage: 50,                 // Open circuit if 50%+ requests fail
    minimumRequests: 10,                            // Need 10+ requests to calculate rate
    recoveryTimeoutMs: 60000,                       // Wait 60s before testing recovery
    successThresholdPercentage: 70,                 // Need 70%+ success to close circuit
    halfOpenMaxRequests: 3                          // Allow 3 test requests in HALF_OPEN
  }
});</code></pre>

                <h3>Shared Circuit Breaker with API Gateway</h3>
                <p>Circuit breaker config is shared across all requests in an API Gateway, providing centralized failure tracking:</p>
                <pre><code class="language-typescript">import { stableApiGateway } from '@emmvish/stable-request';

// Define circuit breaker config
const apiCircuitBreakerConfig = {
  failureThresholdPercentage: 50,
  minimumRequests: 5,
  recoveryTimeoutMs: 60000,
  successThresholdPercentage: 70,
  halfOpenMaxRequests: 3
};

// All requests in this gateway share the same circuit breaker state
const requests = [
  { id: 'users', requestOptions: { reqData: { path: '/users' }, resReq: true } },
  { id: 'orders', requestOptions: { reqData: { path: '/orders' }, resReq: true } },
  { id: 'products', requestOptions: { reqData: { path: '/products' }, resReq: true } }
];

await stableApiGateway(requests, {
  commonRequestData: { hostname: 'api.example.com' },
  circuitBreaker: apiCircuitBreakerConfig,          // Shared state across all requests
  commonAttempts: 3
});</code></pre>

                <h3>Workflow-Level Circuit Breaker</h3>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  commonRequestData: { hostname: 'api.example.com' },
  circuitBreaker: {                                 // Config shared across all phases
    failureThresholdPercentage: 50,
    minimumRequests: 10,
    recoveryTimeoutMs: 60000,
    successThresholdPercentage: 70,
    halfOpenMaxRequests: 3
  },
  commonAttempts: 3
});</code></pre>
            </section>

            <section id="caching" class="doc-section">
                <h2>Response Caching</h2>
                <p>Cache responses to reduce load and improve performance.</p>

                <h3>Basic Caching</h3>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  resReq: true,
  cache: {
    enabled: true,                                  // Enable response caching
    ttl: 300000                                     // Cache for 5 minutes (300,000ms)
  }
});</code></pre>

                <h3>Shared Cache Instance</h3>
                <pre><code class="language-typescript">// Create a shared cache config for multiple requests
const cacheConfig = { enabled: true, ttl: 300000 };

// First request: fetches from API and caches response
await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/users' },
  resReq: true,
  cache: cacheConfig                                          // Use shared cache instance
});

// Second request: returns cached data (within TTL)
await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/users' },
  resReq: true,                                     // Reuses cached data, no API call
});</code></pre>

                <h3>Workflow-Level Caching</h3>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  commonCache: {
    enabled: true,                                  // Cache enabled for all requests
    ttl: 300000                                     // 5-minute cache shared across workflow
  }
});</code></pre>
            </section>

            <section id="rate-limiting" class="doc-section">
                <h2>Rate Limiting & Concurrency Control</h2>

                <h3>Rate Limiting</h3>
                <p>Control request rates to respect API quotas.</p>
                <pre><code class="language-typescript">await stableApiGateway(requests, {
  rateLimit: {
    maxRequests: 100,                               // Maximum 100 requests
    windowMs: 60000                                 // Per 60-second window
  }
});</code></pre>

                <h3>Concurrency Limiting</h3>
                <p>Control the maximum number of simultaneous requests.</p>
                <pre><code class="language-typescript">await stableApiGateway(requests, {
  concurrentExecution: true,                        // Enable parallel execution
  maxConcurrentRequests: 5                          // But limit to 5 simultaneous requests
});</code></pre>

                <h3>Combined Rate & Concurrency Limiting</h3>
                <pre><code class="language-typescript">await stableApiGateway(requests, {
  concurrentExecution: true,
  maxConcurrentRequests: 10,                        // Max 10 parallel requests at a time
  rateLimit: {
    maxRequests: 100,                               // And max 100 requests
    windowMs: 60000                                 // Per minute (rate limit)
  }
});</code></pre>
            </section>

            <section id="workflow-patterns" class="doc-section">
                <h2>Workflow Execution Patterns</h2>

                <h3 id="sequential-concurrent">Sequential & Concurrent Phases</h3>
                    
                    <h4>Sequential Phases (Default)</h4>
                    <p>Phases execute one after another.</p>
                    <pre><code class="language-typescript">const result = await stableWorkflow(phases, {
  concurrentPhaseExecution: false                   // Default: phases run sequentially
});</code></pre>

                    <h4>Concurrent Phases</h4>
                    <p>All phases execute simultaneously.</p>
                    <pre><code class="language-typescript">const result = await stableWorkflow(phases, {
  concurrentPhaseExecution: true                    // All phases start at once
});</code></pre>

                    <h4>Concurrent Requests within Phase</h4>
                    <pre><code class="language-typescript">const phases = [
  {
    id: 'fetch-data',
    concurrentExecution: true,                      // Requests within phase run in parallel
    requests: [...]                                 // While phases themselves may be sequential
  }
];</code></pre>

                <h3 id="mixed-execution">Mixed Execution Mode</h3>
                    <p>Mark specific phases for concurrent execution while others run sequentially.</p>
                    <pre><code class="language-typescript">const phases = [
  {
    id: 'auth',
    requests: [...]                                 // Phase 1: Runs first (sequential)
  },
  {
    id: 'fetch-users',
    markConcurrentPhase: true,                      // Phase 2: Concurrent group starts
    requests: [...]
  },
  {
    id: 'fetch-products',
    markConcurrentPhase: true,                      // Phase 3: Runs with Phase 2 in parallel
    requests: [...]
  },
  {
    id: 'process',
    requests: [...]                                 // Phase 4: Runs after Phases 2 & 3 complete
  }
];

const result = await stableWorkflow(phases, {
  enableMixedExecution: true                        // Enable marking phases for concurrency
});</code></pre>

                <h3 id="non-linear">Non-Linear Workflows</h3>
                    <p>Implement conditional logic with phase decision hooks.</p>
                    
                    <h4>Available Actions</h4>
                    <ul>
                        <li><code>CONTINUE</code>: Proceed to next phase normally</li>
                        <li><code>SKIP</code>: Skip to a specific phase</li>
                        <li><code>JUMP</code>: Jump backwards to re-execute a phase</li>
                        <li><code>REPLAY</code>: Re-execute current phase</li>
                        <li><code>TERMINATE</code>: End workflow immediately</li>
                    </ul>

                    <pre><code class="language-typescript">import { PHASE_DECISION_ACTIONS } from '@emmvish/stable-request';

const phases = [
  {
    id: 'validate',
    requests: [{ id: 'check', requestOptions: { reqData: { path: '/validate' }, resReq: true } }],
    phaseDecisionHook: async ({ phaseResult, sharedBuffer }) => {
      if (!phaseResult.success) {
        return { action: PHASE_DECISION_ACTIONS.TERMINATE }; // End workflow early
      }
      return { action: PHASE_DECISION_ACTIONS.CONTINUE };    // Proceed to next phase
    }
  },
  {
    id: 'process',
    requests: [{ id: 'process', requestOptions: { reqData: { path: '/process' }, resReq: true } }],
    maxReplayCount: 3,                                       // Allow up to 3 replays of this phase
    phaseDecisionHook: async ({ phaseResult, sharedBuffer, replayCount }) => {
      if (phaseResult.failedRequests > 0 && replayCount < 3) {
        return { action: PHASE_DECISION_ACTIONS.REPLAY };    // Retry this phase (replayCount++)
      }
      return { action: PHASE_DECISION_ACTIONS.CONTINUE };    // Success or max replays reached
    }
  },
  {
    id: 'finalize',
    requests: [{ id: 'finalize', requestOptions: { reqData: { path: '/finalize' }, resReq: true } }]
  }
];

const result = await stableWorkflow(phases, {
  enableNonLinearExecution: true,                            // Enable conditional logic
  maxWorkflowIterations: 1000                                // Prevent infinite loops
});</code></pre>

                <h3 id="branched">Branched Workflows</h3>
                    <p>Execute independent branches of work, each with its own phases.</p>
                    
                    <pre><code class="language-typescript">const branches = [
  {
    id: 'user-service',                                      // Branch 1: User operations
    phases: [
      { id: 'validate-user', requests: [{ id: 'validate', requestOptions: { reqData: { path: '/users/validate' }, resReq: true } }] },
      { id: 'update-profile', requests: [{ id: 'update', requestOptions: { reqData: { path: '/users/update', method: REQUEST_METHODS.POST }, resReq: true } }] }
    ]
  },
  {
    id: 'inventory-service',                                 // Branch 2: Inventory operations
    phases: [
      { id: 'check-stock', requests: [{ id: 'check', requestOptions: { reqData: { path: '/inventory/check' }, resReq: true } }] },
      { id: 'reserve-items', requests: [{ id: 'reserve', requestOptions: { reqData: { path: '/inventory/reserve', method: REQUEST_METHODS.POST }, resReq: true } }] }
    ]
  },
  {
    id: 'payment-service',                                   // Branch 3: Payment operations
    phases: [
      { id: 'authorize-payment', requests: [{ id: 'authorize', requestOptions: { reqData: { path: '/payment/authorize', method: REQUEST_METHODS.POST }, resReq: true } }] },
      { id: 'capture-payment', requests: [{ id: 'capture', requestOptions: { reqData: { path: '/payment/capture', method: REQUEST_METHODS.POST }, resReq: true } }] }
    ]
  }
];

const result = await stableWorkflow([], {
  enableBranchExecution: true,                               // Enable branched workflow mode
  branches,                                                  // Define independent branches
  concurrentBranchExecution: true,                           // Run all branches in parallel
  commonRequestData: { hostname: 'api.example.com' },
  handleBranchCompletion: async ({ branchId, success, branchResults }) => {
    console.log(`Branch ${branchId}: ${success ? 'SUCCESS' : 'FAILED'}`);
  }
});</code></pre>

                    <h4>Branch Decision Hooks</h4>
                    <pre><code class="language-typescript">const branches = [
  {
    id: 'critical-service',
    phases: [{
      id: 'critical-operation',
      requests: [{ id: 'critical', requestOptions: { reqData: { path: '/critical' }, resReq: true } }],
      phaseDecisionHook: async ({ phaseResult }) => {
        if (!phaseResult.success) {
          return { 
            action: PHASE_DECISION_ACTIONS.TERMINATE,        // Terminate this branch
          };
        }
        return { action: PHASE_DECISION_ACTIONS.CONTINUE };  // Continue branch execution
      }
    }]
  }
];

const result = await stableWorkflow([], {
  enableBranchExecution: true,
  branches,
  handleBranchDecision: async ({ branchId, decision }) => {
    console.log(`Branch ${branchId} decision:`, decision);    // Monitor branch decisions
  }
});</code></pre>
            </section>

            <section id="observability" class="doc-section">
                <h2>Observability & Hooks</h2>
                <p>Comprehensive hooks for monitoring, logging, and debugging.</p>

                <h3>Request-Level Hooks</h3>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  
  // Called on each failed attempt (before retry)
  handleErrors: async ({ error, errorLog, attempt, totalAttempts }) => {
    logger.error(`Attempt ${attempt}/${totalAttempts} failed:`, errorLog);
  },
  
  // Called on each successful attempt (including retries)
  handleSuccessfulAttemptData: async ({ data, status, attempt }) => {
    logger.info(`Attempt ${attempt} succeeded with status ${status}`);
  },
  
  // Validate responses (return false to retry even on 2xx status)
  responseAnalyzer: async ({ data, status, headers }) => {
    return status === 200 && data.status === 'success';      // Custom validation logic
  },
  
  // Handle final error after all retries exhausted
  finalErrorAnalyzer: async ({ error, allErrors }) => {
    logger.error('All attempts failed:', allErrors);
    return false;                                            // false = throw error, true = suppress
  }
});</code></pre>

                <h3>Workflow-Level Hooks</h3>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  // Called after each phase completes (success or failure)
  handlePhaseCompletion: async ({ 
    phaseResult,                                             // Phase execution results
    sharedBuffer,                                            // Shared workflow state
    params                                                   // Custom parameters
  }) => {
    logger.info(`Phase ${phaseResult.phaseId} completed:`, {
      success: phaseResult.success,
      totalRequests: phaseResult.totalRequests,
      executionTime: phaseResult.executionTime
    });
  },
  
  // Called when phase encounters error
  handlePhaseError: async ({ error, phaseResult, params }) => {
    logger.error(`Phase ${phaseResult.phaseId} failed:`, error);
  },
  
  // Called for non-linear workflow decisions
  handlePhaseDecision: async ({ workflowId, decision, phaseResult }) => {
    console.log(`Phase decision: ${decision.action}`);       // CONTINUE, SKIP, JUMP, REPLAY, TERMINATE
    if (decision.targetPhaseId) {
      console.log(`Target: ${decision.targetPhaseId}`);
    }
  },
  
  // Called when branch needs to take a decision
  handleBranchDecision: async ({ workflowId, branchId, branchResults, success }) => {
    console.log(`Branch ID: ${branchId}`);
  },

  // Called upon branch completion
  handleBranchCompletion: async ({ workflowId, branchResult }) => {
    console.log(`Branch ${branchResult.branchId} completed`);
  },

  // Pass custom parameters to workflow hooks
  workflowHookParams: {
    handlePhaseCompletionParams: { environment: 'production' },
    handlePhaseErrorParams: { severity: 'high' }
  },
});</code></pre>
            </section>

            <section id="pre-execution" class="doc-section">
                <h2>Pre-Execution Hook</h2>
                <p>Dynamically modify requests before they are executed. The pre-execution hook allows you to inspect and transform request data based on the current execution state, making it ideal for adding dynamic headers, authentication, or conditional request modifications.</p>

                <h3>Usage</h3>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  resReq: true,
  preExecution: {
    preExecutionHook: async ({ inputParams, commonBuffer }) => {
      // Modify request data based on buffer state
      const reqData = { ...inputParams.reqData, hostname: commonBuffer.hostname };
      return { reqData };                           // Return modified request data
    }
  },
  commonBuffer: { hostname: 'abc.com' }             // Initial buffer state
});</code></pre>
            </section>

            <section id="trial-mode" class="doc-section">
                <h2>Trial Mode</h2>
                <p>Test without making real API calls using probabilistic success/failure simulation.</p>

                <h3>Basic Trial Mode</h3>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  resReq: true,
  attempts: 3,
  trialMode: {
    enabled: true,                                  // Enable trial mode (no real API calls)
    successProbability: 0.7,                        // 70% chance of simulated success
    trialModeData: { mock: 'data' }                 // Mock response data
  }
});</code></pre>

                <h3>A/B Testing with Trial Mode</h3>
                <pre><code class="language-typescript">// Test feature flags with different success probabilities
const runTest = async (featureName, successRate) => {
  const result = await stableRequest({
    reqData: { hostname: 'api.example.com', path: '/feature-test' },
    resReq: true,
    attempts: 5,
    trialMode: {
      enabled: true,
      successProbability: successRate,              // Variable success rate for testing
      trialModeData: { feature: featureName, enabled: true }
    }
  });
  
  return result;
};

// Test different configurations without real API calls
await runTest('feature-A', 0.9);                    // 90% success rate
await runTest('feature-B', 0.5);                    // 50% success rate</code></pre>
            </section>

            <section id="state-persistence" class="doc-section">
                <h2>State Persistence</h2>
                <p>Persist workflow state to external storage (databases, Redis, file systems) for resilience, recovery, and distributed execution.</p>
                <h3>Configuration</h3>
                <p>State persistence is configured using the <code>StatePersistenceConfig</code> interface:</p>
                <pre><code class="language-typescript">interface StatePersistenceConfig {
  persistenceFunction: (options: StatePersistenceOptions) =&gt; Promise&lt;Record&lt;string, any&gt;&gt; | Record&lt;string, any&gt;;
  persistenceParams?: any;  // Custom parameters passed to your persistence function
  loadBeforeHooks?: boolean;  // Load state before executing hooks (default: false)
  storeAfterHooks?: boolean;  // Store state after hook execution (default: false)
}

interface StatePersistenceOptions {
  executionContext: ExecutionContext;  // Context about current execution
  params?: any;                        // Your custom persistenceParams
  buffer: Record<string, any>;         // The state buffer to store/load
}

interface ExecutionContext {
  workflowId: string;   // Unique workflow identifier
  phaseId?: string;     // Current phase ID (if in a phase)
  branchId?: string;    // Current branch ID (if in a branch)
  requestId?: string;   // Current request ID (if applicable)
}</code></pre>

                <h3>How It Works</h3>
                <p>The persistence function is called in two modes:</p>
                <ul>
                    <li><strong>LOAD Mode:</strong> When <code>buffer</code> is empty/null, return the stored state</li>
                    <li><strong>STORE Mode:</strong> When <code>buffer</code> contains data, save it to your storage</li>
                </ul>
                <pre><code class="language-typescript">// Your persistence function
const myPersistenceFunction = async ({ executionContext, params, buffer }) => {
  if (buffer && Object.keys(buffer).length > 0) {
    // STORE MODE: Save the buffer to storage
    await myStorage.save(executionContext.workflowId, buffer);
    return {};
  } else {
    // LOAD MODE: Return stored state
    const stored = await myStorage.load(executionContext.workflowId);
    return stored || {};  // Return empty object if nothing stored
  }
};</code></pre>
                <h3>Checkpoint-Based Global Persistence</h3>
                <p>Track workflow progress with global checkpoints that persist completed phases:</p>
                <pre><code class="language-typescript">import Redis from 'ioredis';
const redis = new Redis();
async function createCheckpoint({ executionContext, params, buffer }) {
  const { workflowId, phaseId } = executionContext;
  const { ttl = 86400 } = params || {};
  
  const checkpointKey = `checkpoint:${workflowId}`;
  
  if (buffer && Object.keys(buffer).length > 0) {
    // STORE: Save checkpoint with completed phases
    const existingData = await redis.get(checkpointKey);
    const existing = existingData ? JSON.parse(existingData) : {};
    
    const checkpointData = {
      ...existing,
      completedPhases: [...new Set([...(existing.completedPhases || []), ...(buffer.completedPhases || [])])],
      lastPhase: phaseId || existing.lastPhase,
      lastUpdated: new Date().toISOString(),
      progress: buffer.progress || existing.progress || 0,
      processedRecords: buffer.recordsProcessed || existing.processedRecords || 0
    };
    
    await redis.setex(checkpointKey, ttl, JSON.stringify(checkpointData));
    console.log(`Checkpoint saved: ${phaseId} (Progress: ${checkpointData.progress}%)`);
  } else {
    // LOAD: Return checkpoint data
    const data = await redis.get(checkpointKey);
    return data ? JSON.parse(data) : { completedPhases: [], processedRecords: 0 };
  }
  
  return {};
}

// Use global checkpoint for all phases
await stableWorkflow(phases, {
  workflowId: 'migration-12345',
  enableNonLinearExecution: true,                            // Enable conditional logic for skipping
  sharedBuffer: {
    completedPhases: [],                                     // Track which phases completed
    progress: 0
  },
  commonStatePersistence: {
    persistenceFunction: createCheckpoint,                   // Checkpoint function (LOAD/STORE mode)
    persistenceParams: { ttl: 7200 },                        // Custom params: 2 hours TTL
    loadBeforeHooks: true,                                   // Load state before hooks execute
    storeAfterHooks: true                                    // Save state after hooks execute
  }
});</code></pre>
                <p>Resume workflows from checkpoints with automatic phase skipping:</p>
                <pre><code class="language-typescript">// Resume a workflow from last saved state
async function resumeWorkflow(workflowId: string) {
  const phases = [
    {
      id: 'phase-1',
      requests: [...],
      phaseDecisionHook: async ({ phaseResult, sharedBuffer }) => {
        // Check if this phase already completed (recovery scenario)
        if (sharedBuffer.completedPhases?.includes('phase-1')) {
          console.log('Phase-1 already completed, skipping...');
          return { 
            action: PHASE_DECISION_ACTIONS.SKIP,             // Skip completed phase
            skipToPhaseId: 'phase-2'                         // Jump to next incomplete phase
          };
        }
        
        // Verify success before marking complete
        if (phaseResult.success) {
          sharedBuffer.completedPhases = [...(sharedBuffer.completedPhases || []), 'phase-1'];
          console.log('📊 Phase-1 completed, saving checkpoint...');
          return { action: PHASE_DECISION_ACTIONS.CONTINUE };
        }
        
        return { action: PHASE_DECISION_ACTIONS.TERMINATE }; // Fail workflow on error
      },
      statePersistence: {
        persistenceFunction: persistToDatabase,              // Database persistence
        persistenceParams: { db },
        loadBeforeHooks: true,                               // Load before decision hook
        storeAfterHooks: true                                // Save after decision hook
      }
    },
    {
      id: 'phase-2',
      requests: [...],
      phaseDecisionHook: async ({ phaseResult, sharedBuffer }) => {
        if (sharedBuffer.completedPhases?.includes('phase-2')) {
          console.log('Phase-2 already completed, skipping...');
          return { 
            action: PHASE_DECISION_ACTIONS.SKIP, 
            skipToPhaseId: 'phase-3' 
          };
        }
        
        if (phaseResult.success) {
          sharedBuffer.completedPhases = [...(sharedBuffer.completedPhases || []), 'phase-2'];
          return { action: PHASE_DECISION_ACTIONS.CONTINUE };
        }
        
        return { action: PHASE_DECISION_ACTIONS.TERMINATE };
      },
      statePersistence: {
        persistenceFunction: persistToDatabase,
        persistenceParams: { db },
        loadBeforeHooks: true,
        storeAfterHooks: true
      }
    }
  ];
  
  const result = await stableWorkflow(phases, {
    workflowId,
    enableNonLinearExecution: true,                          // Required for SKIP action
    sharedBuffer: { completedPhases: [] }                    // Initialize buffer
  });
  
  return result;
}</code></pre>
            </section>

            <section id="best-practices" class="doc-section">
                <h2>Best Practices</h2>
                <p>Comprehensive guide to building production-ready HTTP workflows using stable-request's full feature set.</p>

                <h3>1. Implement Progressive Retry Strategies</h3>
                <p>Use exponential backoff with jitter for most scenarios to prevent overwhelming services and avoid thundering herd problems.</p>
                <pre><code class="language-typescript">import { stableRequest, RETRY_STRATEGIES } from '@emmvish/stable-request';

await stableRequest({
  reqData: { 
    hostname: 'api.example.com', 
    path: '/data',
    timeout: 5000                               // Always set timeouts to prevent hanging
  },
  attempts: 5,                                  // 5 attempts = 1 initial + 4 retries
  wait: 1000,                                   // Start with 1s delay
  retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,  // 1s, 2s, 4s, 8s growth
  jitter: 500,                                  // ±500ms randomization prevents thundering herd
  maxAllowedWait: 30000,                        // Cap maximum wait at 30s
  logAllErrors: true                            // Track all failures for debugging
});</code></pre>

                <h3>2. Deploy Circuit Breakers for External Dependencies</h3>
                <p>Prevent cascade failures by implementing circuit breakers for all external API calls. Use API Gateway to share circuit breaker config across related requests.</p>
                <pre><code class="language-typescript">import { stableApiGateway } from '@emmvish/stable-request';

// Define circuit breaker config per external service
const paymentServiceBreakerConfig = {
  failureThresholdPercentage: 50,               // Open circuit after 50% failure rate
  minimumRequests: 10,                          // Need 10+ requests to calculate rate
  recoveryTimeoutMs: 60000,                     // Wait 60s before testing recovery (HALF_OPEN)
  successThresholdPercentage: 80,               // Need 80% success to close circuit
  halfOpenMaxRequests: 3                        // Allow 3 test requests in HALF_OPEN state
};

// All payment requests share the same circuit breaker state
const paymentRequests = [
  { id: 'charge', requestOptions: { reqData: { path: '/charge' }, resReq: true, attempts: 3 } },
  { id: 'refund', requestOptions: { reqData: { path: '/refund' }, resReq: true, attempts: 3 } },
  { id: 'validate', requestOptions: { reqData: { path: '/validate' }, resReq: true, attempts: 3 } }
];

await stableApiGateway(paymentRequests, {
  commonRequestData: { hostname: 'payment.api.com' },
  circuitBreaker: paymentServiceBreakerConfig   // Shared circuit state for all payment requests
});</code></pre>

                <h3>3. Leverage Request Grouping for Different SLAs</h3>
                <p>Separate requests by criticality with different retry policies and timeouts.</p>
                <pre><code class="language-typescript">await stableApiGateway(requests, {
  requestGroups: [
    {
      id: 'critical',                           // High-priority requests
      commonConfig: {
        commonAttempts: 7,                      // More retries for critical requests
        commonWait: 2000,
        commonRetryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
        commonJitter: 500,
        commonMaxAllowedWait: 30000
      }
    },
    {
      id: 'optional',                           // Low-priority requests
      commonConfig: {
        commonAttempts: 1,                      // Single attempt for optional data
        commonWait: 500
      }
    }
  ]
});</code></pre>

                <h3>4. Enable Intelligent Caching for Read Operations</h3>
                <p>Cache GET requests with appropriate TTL and custom key generation.</p>
                <pre><code class="language-typescript">const apiCacheConfig = { 
  enabled: true,
  ttl: 300000,                                       // Cache for 5 minutes
  maxSize: 500,                                      // Store max 500 cache entries
  excludeMethods: ['POST', 'PUT', 'PATCH', 'DELETE'] // Only cache safe methods
};

await stableRequest({
  reqData: { path: '/users/profile', method: REQUEST_METHODS.GET },
  resReq: true,
  cache: apiCacheConfig                                   // Shared cache across requests
});</code></pre>

                <h3>5. Build Comprehensive Observability</h3>
                <p>Track all request attempts, failures, and performance metrics.</p>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  // Common error handler: track all failed attempts
  commonHandleErrors: async ({ error, errorLog, attempt, executionContext }) => {
    metrics.increment('api.error', {
      endpoint: executionContext.requestId,         // Which request failed
      attempt: attempt.toString()                   // Which attempt (1, 2, 3...)
    });
    logger.error('Request failed', { attempt, error: errorLog });
  },
  
  // Phase completion handler: track phase performance
  handlePhaseCompletion: async ({ phaseResult }) => {
    metrics.histogram('phase.duration', phaseResult.executionTime); // Track timing
    logger.info('Phase completed', {
      phaseId: phaseResult.phaseId,
      success: phaseResult.success                  // Log success/failure
    });
  }
});</code></pre>

                <h3>6. Master Configuration Cascading</h3>
                <p>Leverage hierarchical configuration for sensible defaults with fine-grained control.</p>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  // Workflow-level defaults (apply to all requests) - Lowest priority
  commonAttempts: 3,
  commonWait: 1000,
  
  // Group-level overrides (apply to matching groupId) - Medium priority
  requestGroups: [{
    id: 'critical',
    commonConfig: {
      commonAttempts: 7                             // Critical requests get 7 attempts
    }
  }]
});
// Final cascade: Request > Group > Phase > Workflow (highest to lowest priority)</code></pre>

                <h3>7. Use Shared Buffers for State Management</h3>
                <p>Share data across phases without global variables.</p>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  sharedBuffer: { configVersion: null, apiKey: null }, // Initialize workflow state
  
  handlePhaseCompletion: async ({ phaseResult, sharedBuffer }) => {
    if (phaseResult.phaseId === 'fetch-config') {
      // Store config data for use in subsequent phases
      sharedBuffer.configVersion = phaseResult.responses[0].data.version;
      sharedBuffer.apiKey = phaseResult.responses[0].data.apiKey;
    }
  }
});</code></pre>

                <h3>8. Implement Smart Pre-Execution Hooks</h3>
                <p>Dynamically modify requests based on runtime conditions.</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  resReq: true,
  commonBuffer: { authToken: null, tokenExpiry: null }, // Track auth state
  
  preExecution: {
    preExecutionHook: async ({ inputParams, commonBuffer, attempt }) => {
      const now = Date.now();
      // Refresh auth token if expired or missing
      if (!commonBuffer.authToken || now >= commonBuffer.tokenExpiry) {
        const tokenResponse = await getAuthToken();
        commonBuffer.authToken = tokenResponse.token;
        commonBuffer.tokenExpiry = now + (tokenResponse.expiresIn * 1000);
      }
      
      // Inject auth token and metadata into request
      const reqData = {
        ...inputParams.reqData,
        headers: {
          'Authorization': `Bearer ${commonBuffer.authToken}`,
          'X-Attempt': attempt.toString()           // Track retry attempt number
        }
      };
      return { reqData };                           // Return modified request
    }
  }
});</code></pre>

                <h3>9. Leverage Non-Linear Workflows</h3>
                <p>Implement conditional execution with phase decision hooks.</p>
                <pre><code class="language-typescript">import { PHASE_DECISION_ACTIONS } from '@emmvish/stable-request';

const phases = [{
  id: 'process-data',
  requests: [{ id: 'process', requestOptions: { reqData: { path: '/process' }, resReq: true } }],
  maxReplayCount: 3,                                // Allow up to 3 replays
  phaseDecisionHook: async ({ phaseResult, replayCount }) => {
    // Retry phase if some requests failed and under replay limit
    if (phaseResult.failedRequests > 0 && replayCount < 3) {
      return { action: PHASE_DECISION_ACTIONS.REPLAY }; // Retry this phase
    }
    // Accept partial success (80%+ success rate)
    if (phaseResult.successfulRequests >= phaseResult.totalRequests * 0.8) {
      return { action: PHASE_DECISION_ACTIONS.CONTINUE }; // Proceed to next phase
    }
    // Fail workflow if below threshold
    return { action: PHASE_DECISION_ACTIONS.TERMINATE }; // Stop workflow
  }
}];

await stableWorkflow(phases, {
  enableNonLinearExecution: true,                   // Enable conditional logic
  maxWorkflowIterations: 1000                       // Prevent infinite loops
});</code></pre>

                <h3>10. Deploy Branched Workflows</h3>
                <p>Execute independent service calls in parallel branches.</p>
                <pre><code class="language-typescript">const branches = [
  {
    id: 'payment-service',                          // Branch 1: Payment flow
    phases: [
      { id: 'authorize-payment', requests: [{ id: 'auth', requestOptions: { reqData: { path: '/payment/authorize', method: REQUEST_METHODS.POST }, resReq: true } }] },
      { id: 'capture-payment', requests: [{ id: 'capture', requestOptions: { reqData: { path: '/payment/capture', method: REQUEST_METHODS.POST }, resReq: true } }] }
    ]
  },
  {
    id: 'notification-service',                     // Branch 2: Notifications (independent)
    markConcurrentBranch: true,                     // Run concurrently with payment
    phases: [
      { id: 'send-email', requests: [{ id: 'email', requestOptions: { reqData: { path: '/notify/email', method: REQUEST_METHODS.POST }, resReq: true } }] },
      { id: 'send-sms', requests: [{ id: 'sms', requestOptions: { reqData: { path: '/notify/sms', method: REQUEST_METHODS.POST }, resReq: true } }] }
    ]
  }
];

await stableWorkflow([], {
  enableBranchExecution: true,                      // Enable branched workflow mode
  branches,                                         // Define independent branches
  concurrentBranchExecution: true,                  // Execute all branches in parallel
  commonRequestData: { hostname: 'api.example.com' } // Shared config across branches
});</code></pre>

                <h3>11. Implement State Persistence</h3>
                <p>Enable recovery from failures with state persistence.</p>
                <pre><code class="language-typescript">import Redis from 'ioredis';
const redis = new Redis();

// Persistence function handles both LOAD and STORE operations
const persistToRedis = async ({ executionContext, buffer }) => {
  const key = `workflow:${executionContext.workflowId}`;
  if (buffer && Object.keys(buffer).length > 0) {
    // STORE MODE: Save state to Redis with 2-hour expiry
    await redis.setex(key, 7200, JSON.stringify(buffer));
    return {};
  }
  // LOAD MODE: Retrieve state from Redis
  const data = await redis.get(key);
  return data ? JSON.parse(data) : {};              // Return empty if no state found
};

await stableWorkflow(phases, {
  commonStatePersistence: {
    persistenceFunction: persistToRedis,            // Persistence handler
    loadBeforeHooks: true,                          // Load state before hooks execute
    storeAfterHooks: true                           // Save state after hooks execute
  }
});</code></pre>

                <h3>12. Use Trial Mode for Testing</h3>
                <p>Test workflow logic without real API calls.</p>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  commonTrialMode: {
    enabled: true,                                  // Enable trial mode (no real API calls)
    successProbability: 0.7,                        // 70% of requests succeed in simulation
    trialModeData: { mock: 'data' }                 // Mock response data returned
  }
});</code></pre>

                <h3>13. Validate Responses Beyond HTTP Status</h3>
                <p>Implement custom response validation.</p>
                <pre><code class="language-typescript">await stableRequest({
  responseAnalyzer: async ({ data, status }) => {
    if (status !== 200) return false;               // Reject non-200 status (retry)
    if (data.status === 'processing') return false; // Job still running (retry)
    if (data.status === 'completed') return true;   // Job complete (accept response)
    throw new Error(`Unexpected status: ${data.status}`); // Fail immediately
  }
});</code></pre>

                <h3>14. Configure Rate Limiting & Concurrency</h3>
                <p>Respect API quotas and prevent resource exhaustion.</p>
                <pre><code class="language-typescript">await stableApiGateway(requests, {
  concurrentExecution: true,                        // Enable parallel execution
  maxConcurrentRequests: 10,                        // But limit to 10 simultaneous
  rateLimit: {
    maxRequests: 100,                               // Maximum 100 requests
    windowMs: 60000                                 // Per 60-second window (rate limit)
  }
});</code></pre>

                <h3>15. Production-Ready Complete Example</h3>
                <p>Combining all patterns for robust production systems.</p>
                <pre><code class="language-typescript">import { 
  stableWorkflow, 
  RETRY_STRATEGIES,
  REQUEST_METHODS,
  PHASE_DECISION_ACTIONS,
} from '@emmvish/stable-request';

// Shared circuit breaker for payment service
const paymentBreakerConfig = {
  failureThresholdPercentage: 50,
  minimumRequests: 10,
  recoveryTimeoutMs: 60000
};
// Shared cache for GET requests
const apiCacheConfig = { enabled: true, ttl: 300000, excludeMethods: ['POST', 'PUT', 'PATCH', 'DELETE'] };

const result = await stableWorkflow([], {
  workflowId: 'order-processing',
  enableBranchExecution: true,                      // Enable branched workflow
  branches: [
    {
      id: 'payment',
      phases: [{
        id: 'charge',
        requests: [{
          id: 'payment',
          requestOptions: {
            reqData: { 
              path: '/payment/charge',
              method: REQUEST_METHODS.POST,
              timeout: 10000                        // 10-second timeout
            },
            resReq: true,
            attempts: 7,                            // 7 attempts for critical payment
            retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
            jitter: 500,                            // Random delay variation
            preExecution: {
              preExecutionHook: async ({ inputParams, commonBuffer }) => {
                // Inject dynamic order amount from shared buffer
                const reqData = {
                  ...inputParams.reqData,
                  body: { amount: commonBuffer.orderAmount }
                };
                return { reqData };
              }
            }
          }
        }],
        statePersistence: {
          persistenceFunction: persistToRedis,      // Enable state persistence
          loadBeforeHooks: true,
          storeAfterHooks: true
        },
        circuitBreaker: paymentBreakerConfig,       // Shared circuit breaker
        commonConfig: {
          commonCache: apiCacheConfig               // Shared cache for GET requests
        }
      }]
    }
  ],
  sharedBuffer: { orderAmount: 100, completedPhases: [] }, // Workflow state
  commonRequestData: { hostname: 'api.example.com' },
  maxConcurrentRequests: 10,                        // Concurrency limit
  rateLimit: { maxRequests: 100, windowMs: 60000 }, // Rate limit
  commonHandleErrors: async ({ error, attempt, executionContext }) => {
    console.error('Request error:', { request: executionContext.requestId, attempt });
  }
});</code></pre>
            </section>
        </main>
    </div>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4>stable-request</h4>
                    <p>Production-grade HTTP Workflow Engine for Node.js</p>
                </div>
                <div class="footer-section">
                    <h4>Links</h4>
                    <ul>
                        <li><a href="https://github.com/Emmvish/stable-request/blob/main/docs/api-references.md">API Reference</a></li>
                        <li><a href="https://github.com/Emmvish/stable-request/issues">Report Issues</a></li>
                        <li><a href="https://github.com/Emmvish/stable-request">GitHub</a></li>
                        <li><a href="https://www.npmjs.com/package/@emmvish/stable-request">npm</a></li>
                        <li><a href="index.html">Home</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Resources</h4>
                    <ul>
                        <li><a href="documentation.html">Documentation</a></li>
                        <li><a href="examples.html">Examples</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2026 Manish Varma (Emmvish).</p>
            </div>
        </div>
    </footer>

    <script>
        hljs.highlightAll();
        
        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });

        // Highlight active section in sidebar
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    document.querySelectorAll('.docs-nav a').forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === `#${id}`) {
                            link.classList.add('active');
                        }
                    });
                }
            });
        }, { rootMargin: '-20% 0px -80% 0px' });

        document.querySelectorAll('.doc-section').forEach(section => {
            observer.observe(section);
        });
        
        // Add copy buttons to all code blocks
        document.querySelectorAll('pre code').forEach((codeBlock) => {
            const pre = codeBlock.parentElement;
            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = 'Copy';
            button.setAttribute('aria-label', 'Copy code to clipboard');
            
            button.addEventListener('click', async () => {
                const code = codeBlock.textContent;
                try {
                    await navigator.clipboard.writeText(code);
                    button.textContent = 'Copied!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    button.textContent = 'Failed';
                    setTimeout(() => {
                        button.textContent = 'Copy';
                    }, 2000);
                }
            });
            
            pre.style.position = 'relative';
            pre.appendChild(button);
        });
    </script>
</body>
</html>
