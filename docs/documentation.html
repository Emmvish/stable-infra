<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation - Stable Request</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚡</text></svg>">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="nav-brand">
                <span class="logo">⚡</span>
                <span class="brand-name">Stable Request</span>
            </a>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="documentation.html" class="active">Documentation</a>
                <a href="examples.html">Examples</a>
                <a href="https://github.com/Emmvish/stable-request" target="_blank">GitHub</a>
            </div>
        </div>
    </nav>

    <div class="docs-container">
        <aside class="docs-sidebar">
            <div class="sidebar-content">
                <h3>Documentation</h3>
                <ul class="docs-nav">
                    <li><a href="#installation">Installation</a></li>
                    <li><a href="#core-functions">Core Functions</a>
                        <ul>
                            <li><a href="#stable-request">stableRequest</a></li>
                            <li><a href="#stable-api-gateway">stableApiGateway</a></li>
                            <li><a href="#stable-workflow">stableWorkflow</a></li>
                        </ul>
                    </li>
                    <li><a href="#config-cascading">Configuration Cascading</a>
                        <ul>
                            <li><a href="#api-gateway-cascading">API Gateway Cascading</a></li>
                            <li><a href="#workflow-cascading">Workflow Cascading</a></li>
                        </ul>
                    </li>
                    <li><a href="#state-buffers">State Buffers</a></li>
                    <li><a href="#retry-strategies">Retry Strategies</a></li>
                    <li><a href="#circuit-breaker">Circuit Breaker</a></li>
                    <li><a href="#caching">Response Caching</a></li>
                    <li><a href="#rate-limiting">Rate Limiting</a></li>
                    <li><a href="#workflow-patterns">Workflow Patterns</a>
                        <ul>
                            <li><a href="#sequential-concurrent">Sequential & Concurrent</a></li>
                            <li><a href="#mixed-execution">Mixed Execution</a></li>
                            <li><a href="#non-linear">Non-Linear Workflows</a></li>
                            <li><a href="#branched">Branched Workflows</a></li>
                        </ul>
                    </li>
                    <li><a href="#observability">Observability</a></li>
                    <li><a href="#pre-execution">Pre-Execution Hook</a></li>
                    <li><a href="#trial-mode">Trial Mode</a></li>
                    <li><a href="#state-persistence">State Persistence</a></li>
                    <li><a href="#best-practices">Best Practices</a></li>
                    <li><a href="https://github.com/Emmvish/stable-request/blob/main/docs/api-references.md" target="_blank">API Reference</a></li>
                </ul>
            </div>
        </aside>

        <main class="docs-main">
            <section id="installation" class="doc-section">
                <h1>Documentation</h1>
                <p class="lead">Complete guide to using stable-request for production-grade HTTP workflows</p>

                <h2>Installation</h2>
                <pre><code class="language-bash">npm install @emmvish/stable-request</code></pre>
                
                <p><strong>Requirements:</strong> Node.js 14+ (ES Modules)</p>
            </section>

            <section id="core-functions" class="doc-section">
                <h2>Core Functions</h2>

                <h3 id="stable-request">stableRequest()</h3>
                    <p>Execute a single HTTP request with built-in retry logic, circuit breaker, caching, and observability hooks.</p>
                    
                    <h4>Signature</h4>
                    <pre><code class="language-typescript">function stableRequest&lt;RequestDataType = any, ResponseDataType = any&gt;(
  options: STABLE_REQUEST&lt;RequestDataType, ResponseDataType&gt;
): Promise&lt;ResponseDataType | false&gt;</code></pre>

                    <h4>Basic Usage</h4>
                    <pre><code class="language-typescript">import { stableRequest, RETRY_STRATEGIES } from '@emmvish/stable-request';

const userData = await stableRequest({
  reqData: {
    hostname: 'api.example.com',
    path: '/users/123',
    method: 'GET',
    headers: { 'Authorization': 'Bearer token' }
  },
  resReq: true,              // Return response data
  attempts: 3,               // Retry up to 3 times
  wait: 1000,                // 1 second between retries
  retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
  logAllErrors: true
});</code></pre>

                    <h4>STABLE_REQUEST Interface</h4>
                    <p>Complete parameter reference for the <code>stableRequest</code> function options:</p>
                    <div class="table-wrapper">
                    <table class="params-table">
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th>Required</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>reqData</code></td>
                                <td><code>REQUEST_DATA&lt;RequestDataType&gt;</code></td>
                                <td>-</td>
                                <td>Yes</td>
                                <td>Request configuration including hostname, path, method, headers, body, query, timeout, protocol, port, signal</td>
                            </tr>
                            <tr>
                                <td><code>responseAnalyzer</code></td>
                                <td><code>(options: ResponseAnalysisHookOptions&lt;RequestDataType, ResponseDataType&gt;) =&gt; boolean | Promise&lt;boolean&gt;</code></td>
                                <td><code>() => true</code></td>
                                <td>No</td>
                                <td>Custom function to validate response content. Return <code>false</code> to trigger retry, <code>true</code> if response is acceptable</td>
                            </tr>
                            <tr>
                                <td><code>resReq</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, returns response data. If <code>false</code>, returns <code>true</code> on success or <code>false</code> on failure</td>
                            </tr>
                            <tr>
                                <td><code>attempts</code></td>
                                <td><code>number</code></td>
                                <td><code>1</code></td>
                                <td>No</td>
                                <td>Maximum number of attempts (including initial request). Must be ≥ 1</td>
                            </tr>
                            <tr>
                                <td><code>performAllAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, performs all attempts even if one succeeds (useful for testing)</td>
                            </tr>
                            <tr>
                                <td><code>wait</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Base wait time in milliseconds between retry attempts</td>
                            </tr>
                            <tr>
                                <td><code>maxAllowedWait</code></td>
                                <td><code>number</code></td>
                                <td><code>60000</code></td>
                                <td>No</td>
                                <td>Maximum allowed wait time between retries (caps the backoff calculation)</td>
                            </tr>
                            <tr>
                                <td><code>retryStrategy</code></td>
                                <td><code>RETRY_STRATEGY_TYPES</code></td>
                                <td><code>FIXED</code></td>
                                <td>No</td>
                                <td>Retry backoff strategy: <code>FIXED</code>, <code>LINEAR</code>, or <code>EXPONENTIAL</code></td>
                            </tr>
                            <tr>
                                <td><code>jitter</code></td>
                                <td><code>number</code></td>
                                <td><code>0</code></td>
                                <td>No</td>
                                <td>Random delay variation in milliseconds. If non-zero, applies randomized jitter to retry delays to prevent thundering herd</td>
                            </tr>
                            <tr>
                                <td><code>logAllErrors</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, logs all error attempts to console</td>
                            </tr>
                            <tr>
                                <td><code>handleErrors</code></td>
                                <td><code>(options: HandleErrorHookOptions&lt;RequestDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Custom error handler called for each failed attempt</td>
                            </tr>
                            <tr>
                                <td><code>logAllSuccessfulAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, logs all successful attempts to console</td>
                            </tr>
                            <tr>
                                <td><code>handleSuccessfulAttemptData</code></td>
                                <td><code>(options: HandleSuccessfulAttemptDataHookOptions&lt;RequestDataType, ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Custom handler called for each successful attempt</td>
                            </tr>
                            <tr>
                                <td><code>maxSerializableChars</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Maximum characters to include when serializing objects in logs</td>
                            </tr>
                            <tr>
                                <td><code>finalErrorAnalyzer</code></td>
                                <td><code>(options: FinalErrorAnalysisHookOptions&lt;RequestDataType&gt;) =&gt; boolean | Promise&lt;boolean&gt;</code></td>
                                <td><code>() => false</code></td>
                                <td>No</td>
                                <td>Analyzes the final error after all retries exhausted. Return <code>true</code> to suppress error (return <code>false</code>), <code>false</code> to throw</td>
                            </tr>
                            <tr>
                                <td><code>trialMode</code></td>
                                <td><code>TRIAL_MODE_OPTIONS</code></td>
                                <td><code>{ enabled: false }</code></td>
                                <td>No</td>
                                <td>Enables trial mode for testing without making real API calls. Configure failure probabilities and latency ranges</td>
                            </tr>
                            <tr>
                                <td><code>hookParams</code></td>
                                <td><code>HookParams</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Custom parameters to pass to hook functions (responseAnalyzerParams, handleErrorsParams, handleSuccessfulAttemptDataParams, finalErrorAnalyzerParams)</td>
                            </tr>
                            <tr>
                                <td><code>preExecution</code></td>
                                <td><code>RequestPreExecutionOptions</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Pre-execution hook configuration for dynamic request modification before execution</td>
                            </tr>
                            <tr>
                                <td><code>commonBuffer</code></td>
                                <td><code>Record&lt;string, any&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Shared buffer for storing/accessing data across requests, hooks, and workflow phases</td>
                            </tr>
                            <tr>
                                <td><code>cache</code></td>
                                <td><code>CacheConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Response caching configuration with TTL, cache control, status codes, and custom key generation</td>
                            </tr>
                            <tr>
                                <td><code>executionContext</code></td>
                                <td><code>ExecutionContext</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Execution context for logging and traceability (workflowId, phaseId, branchId, requestId)</td>
                            </tr>
                            <tr>
                                <td><code>circuitBreaker</code></td>
                                <td><code>CircuitBreakerConfig | CircuitBreaker</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Circuit breaker configuration or instance to prevent cascade failures and system overload</td>
                            </tr>
                            <tr>
                                <td><code>statePersistence</code></td>
                                <td><code>StatePersistenceConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>State persistence configuration for saving/loading workflow state to external storage (Redis, MongoDB, File System)</td>
                            </tr>
                        </tbody>
                    </table>
                    </div>

                <h3 id="stable-api-gateway">stableApiGateway()</h3>
                    <p>Execute multiple HTTP requests either sequentially or concurrently with unified configuration.</p>
                    
                    <h4>Signature</h4>
                    <pre><code class="language-typescript">function stableApiGateway&lt;RequestDataType = any, ResponseDataType = any&gt;(
  requests: API_GATEWAY_REQUEST&lt;RequestDataType, ResponseDataType&gt;[],
  options: API_GATEWAY_OPTIONS&lt;RequestDataType, ResponseDataType&gt;
): Promise&lt;API_GATEWAY_RESPONSE&lt;ResponseDataType&gt;[]&gt;</code></pre>

                    <h4>Concurrent Execution</h4>
                    <pre><code class="language-typescript">import { stableApiGateway } from '@emmvish/stable-request';

const requests = [
  { id: 'users', requestOptions: { 
    reqData: { path: '/users' }, resReq: true 
  }},
  { id: 'orders', requestOptions: { 
    reqData: { path: '/orders' }, resReq: true 
  }},
  { id: 'products', requestOptions: { 
    reqData: { path: '/products' }, resReq: true 
  }}
];

const results = await stableApiGateway(requests, {
  concurrentExecution: true,    // Execute in parallel
  commonRequestData: { 
    hostname: 'api.example.com',
    headers: { 'X-API-Key': 'secret' }
  },
  commonAttempts: 2,
  commonWait: 500,
  stopOnFirstError: false        // Continue all even if some fail
});

results.forEach(result => {
  console.log(`${result.id}:`, result.success ? result.data : result.error);
});</code></pre>

                    <h4>Sequential Execution</h4>
                    <pre><code class="language-typescript">const results = await stableApiGateway(requests, {
  concurrentExecution: false,    // Execute one at a time
  stopOnFirstError: true,        // Stop after first failure
  commonRequestData: { hostname: 'api.example.com' },
  commonAttempts: 3
});</code></pre>

                    <h4>Request Grouping</h4>
                    <p>Apply different configurations to groups of requests:</p>
                    <pre><code class="language-typescript">const requests = [
  { id: 'critical-1', groupId: 'critical', requestOptions: {...} },
  { id: 'critical-2', groupId: 'critical', requestOptions: {...} },
  { id: 'optional-1', groupId: 'optional', requestOptions: {...} },
];

const results = await stableApiGateway(requests, {
  concurrentExecution: true,
  commonAttempts: 1,
  requestGroups: [
    {
      groupId: 'critical',
      commonAttempts: 5,          // Critical requests retry more
      commonWait: 1000,
      commonRetryStrategy: RETRY_STRATEGIES.EXPONENTIAL
    },
    {
      groupId: 'optional',
      commonAttempts: 2,          // Optional requests retry less
      commonWait: 500
    }
  ]
});</code></pre>

                    <h4>API_GATEWAY_OPTIONS Interface</h4>
                    <p>Complete parameter reference for the <code>stableApiGateway</code> function options:</p>
                    <div class="table-wrapper">
                    <table class="params-table">
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th>Required</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>commonRequestData</code></td>
                                <td><code>Partial&lt;REQUEST_DATA&lt;RequestDataType&gt;&gt;</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Common request configuration applied to all requests (hostname, headers, protocol, etc.)</td>
                            </tr>
                            <tr>
                                <td><code>commonAttempts</code></td>
                                <td><code>number</code></td>
                                <td><code>1</code></td>
                                <td>No</td>
                                <td>Default number of retry attempts for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonHookParams</code></td>
                                <td><code>HookParams</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Default hook parameters for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonPerformAllAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default performAllAttempts setting for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonWait</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Default wait time between retries for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonMaxAllowedWait</code></td>
                                <td><code>number</code></td>
                                <td><code>60000</code></td>
                                <td>No</td>
                                <td>Default maximum wait time for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonRetryStrategy</code></td>
                                <td><code>RETRY_STRATEGY_TYPES</code></td>
                                <td><code>FIXED</code></td>
                                <td>No</td>
                                <td>Default retry strategy for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonJitter</code></td>
                                <td><code>number</code></td>
                                <td><code>0</code></td>
                                <td>No</td>
                                <td>Default jitter setting for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonLogAllErrors</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default error logging setting for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonLogAllSuccessfulAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default success logging setting for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonMaxSerializableChars</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Default max chars for serialization in logs</td>
                            </tr>
                            <tr>
                                <td><code>commonTrialMode</code></td>
                                <td><code>TRIAL_MODE_OPTIONS</code></td>
                                <td><code>{ enabled: false }</code></td>
                                <td>No</td>
                                <td>Default trial mode configuration for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonResponseAnalyzer</code></td>
                                <td><code>(options: ResponseAnalysisHookOptions&lt;RequestDataType, ResponseDataType&gt;) =&gt; boolean | Promise&lt;boolean&gt;</code></td>
                                <td><code>() => true</code></td>
                                <td>No</td>
                                <td>Default response analyzer for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonResReq</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default resReq value for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonFinalErrorAnalyzer</code></td>
                                <td><code>(options: FinalErrorAnalysisHookOptions&lt;RequestDataType&gt;) =&gt; boolean | Promise&lt;boolean&gt;</code></td>
                                <td><code>() => false</code></td>
                                <td>No</td>
                                <td>Default final error analyzer for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonHandleErrors</code></td>
                                <td><code>(options: HandleErrorHookOptions&lt;RequestDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Default error handler for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonHandleSuccessfulAttemptData</code></td>
                                <td><code>(options: HandleSuccessfulAttemptDataHookOptions&lt;RequestDataType, ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Default success handler for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonPreExecution</code></td>
                                <td><code>RequestPreExecutionOptions</code></td>
                                <td><code>() => {}</code></td>
                                <td>No</td>
                                <td>Default pre-execution hook configuration for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonCache</code></td>
                                <td><code>CacheConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Default cache configuration for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonStatePersistence</code></td>
                                <td><code>StatePersistenceConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Default state persistence configuration for all requests</td>
                            </tr>
                            <tr>
                                <td><code>concurrentExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>true</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, executes all requests concurrently. If <code>false</code>, executes sequentially</td>
                            </tr>
                            <tr>
                                <td><code>requestGroups</code></td>
                                <td><code>RequestGroup&lt;RequestDataType, ResponseDataType&gt;[]</code></td>
                                <td><code>[]</code></td>
                                <td>No</td>
                                <td>Array of request group configurations for applying settings to specific groups</td>
                            </tr>
                            <tr>
                                <td><code>stopOnFirstError</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, stops executing remaining requests after first error (sequential mode) or stops launching new requests (concurrent mode)</td>
                            </tr>
                            <tr>
                                <td><code>sharedBuffer</code></td>
                                <td><code>Record&lt;string, any&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Shared buffer accessible by all requests for data exchange</td>
                            </tr>
                            <tr>
                                <td><code>maxConcurrentRequests</code></td>
                                <td><code>number</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Maximum number of concurrent requests (concurrent mode only)</td>
                            </tr>
                            <tr>
                                <td><code>rateLimit</code></td>
                                <td><code>RateLimitConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Rate limiting configuration (maxRequests, windowMs)</td>
                            </tr>
                            <tr>
                                <td><code>circuitBreaker</code></td>
                                <td><code>CircuitBreakerConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Circuit breaker configuration shared across all requests</td>
                            </tr>
                            <tr>
                                <td><code>executionContext</code></td>
                                <td><code>Partial&lt;ExecutionContext&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Execution context for logging and traceability</td>
                            </tr>
                        </tbody>
                    </table>
                    </div>

                <h3 id="stable-workflow">stableWorkflow()</h3>
                    <p>Orchestrate complex multi-phase API workflows with support for sequential, concurrent, mixed, non-linear, and branching execution patterns.</p>
                    
                    <h4>Signature</h4>
                    <pre><code class="language-typescript">function stableWorkflow&lt;RequestDataType = any, ResponseDataType = any&gt;(
  phases: STABLE_WORKFLOW_PHASE&lt;RequestDataType, ResponseDataType&gt;[],
  options: STABLE_WORKFLOW_OPTIONS&lt;RequestDataType, ResponseDataType&gt;
): Promise&lt;STABLE_WORKFLOW_RESULT&lt;ResponseDataType&gt;&gt;</code></pre>

                    <h4>Basic Multi-Phase Workflow</h4>
                    <pre><code class="language-typescript">import { stableWorkflow } from '@emmvish/stable-request';

const phases = [
  {
    id: 'authentication',
    requests: [
      { 
        id: 'login', 
        requestOptions: { 
          reqData: { path: '/auth/login', method: 'POST' },
          resReq: true 
        }
      }
    ]
  },
  {
    id: 'fetch-data',
    concurrentExecution: true,    // Requests in this phase run in parallel
    requests: [
      { id: 'profile', requestOptions: { reqData: { path: '/profile' }, resReq: true }},
      { id: 'orders', requestOptions: { reqData: { path: '/orders' }, resReq: true }},
      { id: 'settings', requestOptions: { reqData: { path: '/settings' }, resReq: true }}
    ]
  },
  {
    id: 'process-data',
    requests: [
      { id: 'analytics', requestOptions: { 
        reqData: { path: '/analytics', method: 'POST' },
        resReq: false 
      }}
    ]
  }
];

const result = await stableWorkflow(phases, {
  workflowId: 'user-data-sync',
  commonRequestData: { hostname: 'api.example.com' },
  commonAttempts: 3,
  stopOnFirstPhaseError: true,
  logPhaseResults: true
});

console.log(`Workflow completed: ${result.success}`);
console.log(`Total requests: ${result.totalRequests}`);
console.log(`Successful: ${result.successfulRequests}`);
console.log(`Failed: ${result.failedRequests}`);
console.log(`Execution time: ${result.executionTime}ms`);</code></pre>

                    <h4>STABLE_WORKFLOW_PHASE Interface</h4>
                    <p>Complete parameter reference for defining individual workflow phases:</p>
                    <div class="table-wrapper">
                    <table class="params-table">
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th>Required</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>id</code></td>
                                <td><code>string</code></td>
                                <td><code>auto-generated</code></td>
                                <td>No</td>
                                <td>Unique identifier for the phase. Auto-generated if not provided</td>
                            </tr>
                            <tr>
                                <td><code>requests</code></td>
                                <td><code>API_GATEWAY_REQUEST[]</code></td>
                                <td>-</td>
                                <td>Yes</td>
                                <td>Array of requests to execute in this phase</td>
                            </tr>
                            <tr>
                                <td><code>concurrentExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, executes all requests in this phase concurrently. If <code>false</code>, executes sequentially</td>
                            </tr>
                            <tr>
                                <td><code>stopOnFirstError</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, stops executing remaining requests in this phase after first error</td>
                            </tr>
                            <tr>
                                <td><code>markConcurrentPhase</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Mark this phase for concurrent execution in mixed execution mode. Used with <code>enableMixedExecution</code></td>
                            </tr>
                            <tr>
                                <td><code>maxConcurrentRequests</code></td>
                                <td><code>number</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Maximum number of concurrent requests for this phase. Overrides workflow-level setting</td>
                            </tr>
                            <tr>
                                <td><code>rateLimit</code></td>
                                <td><code>RateLimitConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Rate limiting configuration for this phase. Overrides workflow-level setting</td>
                            </tr>
                            <tr>
                                <td><code>circuitBreaker</code></td>
                                <td><code>CircuitBreakerConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Circuit breaker configuration for this phase. Overrides workflow-level setting</td>
                            </tr>
                            <tr>
                                <td><code>maxReplayCount</code></td>
                                <td><code>number</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Maximum number of times this phase can be replayed in non-linear workflows</td>
                            </tr>
                            <tr>
                                <td><code>allowReplay</code></td>
                                <td><code>boolean</code></td>
                                <td><code>true</code></td>
                                <td>No</td>
                                <td>Whether this phase can be replayed via phase decision hook</td>
                            </tr>
                            <tr>
                                <td><code>allowSkip</code></td>
                                <td><code>boolean</code></td>
                                <td><code>true</code></td>
                                <td>No</td>
                                <td>Whether this phase can be skipped via phase decision hook</td>
                            </tr>
                            <tr>
                                <td><code>phaseDecisionHook</code></td>
                                <td><code>(options: PhaseDecisionHookOptions) =&gt; PhaseExecutionDecision | Promise&lt;PhaseExecutionDecision&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Hook function to determine what action to take after this phase completes. Used for non-linear workflows. Returns decision with action: CONTINUE, SKIP, JUMP, REPLAY, or TERMINATE</td>
                            </tr>
                            <tr>
                                <td><code>commonConfig</code></td>
                                <td><code>Partial&lt;API_GATEWAY_OPTIONS&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Phase-level configuration containing all <code>common*</code> properties from API_GATEWAY_OPTIONS interface (e.g., commonAttempts, commonWait, commonRetryStrategy, commonRequestData, etc.). These settings apply to all requests in this phase and override workflow-level common settings</td>
                            </tr>
                            <tr>
                                <td><code>branchId</code></td>
                                <td><code>string</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Branch identifier when this phase is part of a branched workflow</td>
                            </tr>
                            <tr>
                                <td><code>statePersistence</code></td>
                                <td><code>StatePersistenceConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>State persistence configuration for this phase. Allows saving/loading phase state to external storage</td>
                            </tr>
                        </tbody>
                    </table>
                    </div>

                    <h4>STABLE_WORKFLOW_OPTIONS Interface</h4>
                    <p>Complete parameter reference for the <code>stableWorkflow</code> function options. Extends all <code>API_GATEWAY_OPTIONS</code> plus workflow-specific parameters:</p>
                    <div class="table-wrapper">
                    <table class="params-table">
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th>Required</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>workflowId</code></td>
                                <td><code>string</code></td>
                                <td><code>'workflow-{timestamp}'</code></td>
                                <td>No</td>
                                <td>Unique identifier for this workflow execution</td>
                            </tr>
                            <tr>
                                <td><code>stopOnFirstPhaseError</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, stops workflow execution after first phase error</td>
                            </tr>
                            <tr>
                                <td><code>logPhaseResults</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, logs each phase result to console</td>
                            </tr>
                            <tr>
                                <td><code>concurrentPhaseExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>If <code>true</code>, all phases execute concurrently. If <code>false</code>, phases execute sequentially</td>
                            </tr>
                            <tr>
                                <td><code>enableBranchExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Enables branch-based workflow execution with independent branches</td>
                            </tr>
                            <tr>
                                <td><code>branches</code></td>
                                <td><code>STABLE_WORKFLOW_BRANCH&lt;RequestDataType, ResponseDataType&gt;[]</code></td>
                                <td><code>[]</code></td>
                                <td>No</td>
                                <td>Array of workflow branches (when enableBranchExecution is true)</td>
                            </tr>
                            <tr>
                                <td><code>enableMixedExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Enables mixed execution mode where phases can be marked for concurrent execution using markConcurrentPhase</td>
                            </tr>
                            <tr>
                                <td><code>enableNonLinearExecution</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Enables non-linear execution with phase decision hooks (JUMP, SKIP, REPLAY, TERMINATE)</td>
                            </tr>
                            <tr>
                                <td><code>maxWorkflowIterations</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Maximum total phase executions to prevent infinite loops in non-linear workflows</td>
                            </tr>
                            <tr>
                                <td><code>statePersistence</code></td>
                                <td><code>StatePersistenceConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>State persistence configuration for workflow recovery and distributed execution</td>
                            </tr>
                            <tr>
                                <td><code>handlePhaseCompletion</code></td>
                                <td><code>(options: HandlePhaseCompletionHookOptions&lt;ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Hook called after each phase completes successfully. Receives workflowId, branchId, phaseResult, params, sharedBuffer</td>
                            </tr>
                            <tr>
                                <td><code>handlePhaseError</code></td>
                                <td><code>(options: HandlePhaseErrorHookOptions&lt;ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Hook called when a phase encounters an error</td>
                            </tr>
                            <tr>
                                <td><code>handlePhaseDecision</code></td>
                                <td><code>(decision: PhaseExecutionDecision, phaseResult: STABLE_WORKFLOW_PHASE_RESULT&lt;ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => {}</code></td>
                                <td>No</td>
                                <td>Hook called when a phase makes a non-linear decision (JUMP, SKIP, REPLAY, TERMINATE)</td>
                            </tr>
                            <tr>
                                <td><code>handleBranchCompletion</code></td>
                                <td><code>(options: {workflowId, branchId, branchResults, success}) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Hook called when a branch completes. Receives workflowId, branchId, branchResults, success</td>
                            </tr>
                            <tr>
                                <td><code>handleBranchDecision</code></td>
                                <td><code>(decision: BranchExecutionDecision, branchResult: BranchExecutionResult&lt;ResponseDataType&gt;) =&gt; any | Promise&lt;any&gt;</code></td>
                                <td><code>() => {}</code></td>
                                <td>No</td>
                                <td>Hook called when a branch makes a decision</td>
                            </tr>
                            <tr>
                                <td><code>maxSerializableChars</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Maximum characters for serialization in logs</td>
                            </tr>
                            <tr>
                                <td><code>workflowHookParams</code></td>
                                <td><code>WorkflowHookParams</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Custom parameters passed to workflow-level hooks (handlePhaseCompletionParams, handlePhaseErrorParams, handlePhaseDecisionParams, handleBranchDecisionParams)</td>
                            </tr>
                            <tr>
                                <td><code>commonRequestData</code></td>
                                <td><code>Partial&lt;REQUEST_DATA&gt;</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Common request configuration applied to all phases</td>
                            </tr>
                            <tr>
                                <td><code>commonAttempts</code></td>
                                <td><code>number</code></td>
                                <td><code>1</code></td>
                                <td>No</td>
                                <td>Default retry attempts for all requests</td>
                            </tr>
                            <tr>
                                <td><code>commonWait</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Default wait time between retries</td>
                            </tr>
                            <tr>
                                <td><code>commonRetryStrategy</code></td>
                                <td><code>RETRY_STRATEGY_TYPES</code></td>
                                <td><code>FIXED</code></td>
                                <td>No</td>
                                <td>Default retry strategy</td>
                            </tr>
                            <tr>
                                <td><code>commonCache</code></td>
                                <td><code>CacheConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Default cache configuration</td>
                            </tr>
                            <tr>
                                <td><code>commonStatePersistence</code></td>
                                <td><code>StatePersistenceConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Default state persistence for all phases</td>
                            </tr>
                            <tr>
                                <td><code>circuitBreaker</code></td>
                                <td><code>CircuitBreakerConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Circuit breaker shared across workflow</td>
                            </tr>
                            <tr>
                                <td><code>rateLimit</code></td>
                                <td><code>RateLimitConfig</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Rate limiting configuration</td>
                            </tr>
                            <tr>
                                <td><code>maxConcurrentRequests</code></td>
                                <td><code>number</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Maximum concurrent requests</td>
                            </tr>
                            <tr>
                                <td><code>sharedBuffer</code></td>
                                <td><code>Record&lt;string, any&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Shared buffer for data exchange across phases</td>
                            </tr>
                            <tr>
                                <td><code>requestGroups</code></td>
                                <td><code>RequestGroup[]</code></td>
                                <td><code>[]</code></td>
                                <td>No</td>
                                <td>Request group configurations</td>
                            </tr>
                            <tr>
                                <td><code>commonHookParams</code></td>
                                <td><code>HookParams</code></td>
                                <td><code>{}</code></td>
                                <td>No</td>
                                <td>Default hook parameters</td>
                            </tr>
                            <tr>
                                <td><code>commonPerformAllAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default performAllAttempts setting</td>
                            </tr>
                            <tr>
                                <td><code>commonMaxAllowedWait</code></td>
                                <td><code>number</code></td>
                                <td><code>60000</code></td>
                                <td>No</td>
                                <td>Default maximum wait time</td>
                            </tr>
                            <tr>
                                <td><code>commonJitter</code></td>
                                <td><code>number</code></td>
                                <td><code>0</code></td>
                                <td>No</td>
                                <td>Default jitter setting</td>
                            </tr>
                            <tr>
                                <td><code>commonLogAllErrors</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default error logging</td>
                            </tr>
                            <tr>
                                <td><code>commonLogAllSuccessfulAttempts</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default success logging</td>
                            </tr>
                            <tr>
                                <td><code>commonMaxSerializableChars</code></td>
                                <td><code>number</code></td>
                                <td><code>1000</code></td>
                                <td>No</td>
                                <td>Default max serialization chars</td>
                            </tr>
                            <tr>
                                <td><code>commonTrialMode</code></td>
                                <td><code>TRIAL_MODE_OPTIONS</code></td>
                                <td><code>{ enabled: false }</code></td>
                                <td>No</td>
                                <td>Default trial mode</td>
                            </tr>
                            <tr>
                                <td><code>commonResponseAnalyzer</code></td>
                                <td><code>Function</code></td>
                                <td><code>() => true</code></td>
                                <td>No</td>
                                <td>Default response analyzer</td>
                            </tr>
                            <tr>
                                <td><code>commonResReq</code></td>
                                <td><code>boolean</code></td>
                                <td><code>false</code></td>
                                <td>No</td>
                                <td>Default resReq value</td>
                            </tr>
                            <tr>
                                <td><code>commonFinalErrorAnalyzer</code></td>
                                <td><code>Function</code></td>
                                <td><code>() => false</code></td>
                                <td>No</td>
                                <td>Default final error analyzer</td>
                            </tr>
                            <tr>
                                <td><code>commonHandleErrors</code></td>
                                <td><code>Function</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Default error handler</td>
                            </tr>
                            <tr>
                                <td><code>commonHandleSuccessfulAttemptData</code></td>
                                <td><code>Function</code></td>
                                <td><code>() => console.log</code></td>
                                <td>No</td>
                                <td>Default success handler</td>
                            </tr>
                            <tr>
                                <td><code>commonPreExecution</code></td>
                                <td><code>RequestPreExecutionOptions</code></td>
                                <td><code>() => {}</code></td>
                                <td>No</td>
                                <td>Default pre-execution hook</td>
                            </tr>
                            <tr>
                                <td><code>executionContext</code></td>
                                <td><code>Partial&lt;ExecutionContext&gt;</code></td>
                                <td><code>undefined</code></td>
                                <td>No</td>
                                <td>Execution context for logging</td>
                            </tr>
                        </tbody>
                    </table>
                    </div>
            </section>

            <section id="config-cascading" class="doc-section">
                <h2>Configuration Cascading</h2>
                <p>Understand how configuration options cascade and override from higher levels to lower levels, allowing you to set defaults globally while customizing specific requests.</p>

                <h3>Cascading Principles</h3>
                <p>Configuration follows a hierarchical override pattern where:</p>
                <ul>
                    <li><strong>Lower-level configurations override higher-level ones</strong></li>
                    <li><strong>More specific settings take precedence over general settings</strong></li>
                    <li><strong>Request-level options always have the highest priority</strong></li>
                </ul>

                <h3 id="api-gateway-cascading">API Gateway Configuration Cascading</h3>
                <p>In <code>stableApiGateway</code>, configuration flows from gateway options to individual requests:</p>
                
                <div class="hierarchy-diagram">
                    <pre><code class="language-text">Gateway Options (common*)
    ↓
Request Group Options (for matching groupId)
    ↓
Individual Request Options
    ↓
<strong>Final Configuration Applied</strong></code></pre>
                </div>

                <h4>Cascading Hierarchy</h4>
                <ol>
                    <li><strong>Gateway-Level (Lowest Priority):</strong> <code>common*</code> options apply to all requests
                        <ul>
                            <li><code>commonRequestData</code> - Shared request configuration (hostname, headers, etc.)</li>
                            <li><code>commonAttempts</code> - Default retry attempts</li>
                            <li><code>commonWait</code> - Default wait time between retries</li>
                            <li><code>commonRetryStrategy</code> - Default retry strategy</li>
                            <li><code>commonJitter</code> - Default jitter setting</li>
                            <li>And all other <code>common*</code> properties...</li>
                        </ul>
                    </li>
                    <li><strong>Request Group-Level (Medium Priority):</strong> Settings for specific request groups override gateway defaults</li>
                    <li><strong>Request-Level (Highest Priority):</strong> Individual request options override all others</li>
                </ol>

                <h4>Example: API Gateway Cascading</h4>
                <pre><code class="language-typescript">const requests = [
  { 
    id: 'user-1', 
    groupId: 'critical',
    requestOptions: { 
      reqData: { path: '/users/1' },
      attempts: 7  // Overrides group and gateway settings
    }
  },
  { 
    id: 'user-2', 
    groupId: 'critical',
    requestOptions: { 
      reqData: { path: '/users/2' }
      // Uses group settings (5 attempts)
    }
  },
  { 
    id: 'analytics', 
    groupId: 'optional',
    requestOptions: { 
      reqData: { path: '/analytics' }
      // Uses group settings (1 attempt)
    }
  },
  { 
    id: 'logs', 
    requestOptions: { 
      reqData: { path: '/logs' }
      // No groupId, uses gateway defaults (3 attempts)
    }
  }
];

await stableApiGateway(requests, {
  // Gateway-Level (applies to all)
  commonRequestData: { 
    hostname: 'api.example.com',
    headers: { 'X-API-Key': 'secret' }
  },
  commonAttempts: 3,              // Default for all
  commonWait: 1000,
  commonRetryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
  
  // Request Group-Level (overrides gateway defaults)
  requestGroups: [
    {
      groupId: 'critical',
      commonAttempts: 5,          // Overrides gateway's 3
      commonWait: 2000            // Overrides gateway's 1000
    },
    {
      groupId: 'optional',
      commonAttempts: 1,          // Overrides gateway's 3
      commonWait: 500             // Overrides gateway's 1000
    }
  ]
});

// Final Configuration Applied:
// user-1:     7 attempts, 1000ms wait (request-level attempts, gateway wait)
// user-2:     5 attempts, 2000ms wait (group-level overrides)
// analytics:  1 attempt,  500ms wait  (group-level overrides)
// logs:       3 attempts, 1000ms wait (gateway-level defaults)</code></pre>

                <h3 id="workflow-cascading">Workflow Configuration Cascading</h3>
                <p>In <code>stableWorkflow</code>, configuration flows through multiple layers:</p>
                
                <div class="hierarchy-diagram">
                    <pre><code class="language-text">Workflow Options (common*)
    ↓
Branch Configuration (in branched workflows)
    ↓
Phase Configuration (commonConfig property)
    ↓
Request Group Options (for matching groupId)
    ↓
Individual Request Options
    ↓
<strong>Final Configuration Applied</strong></code></pre>
                </div>

                <h4>Cascading Hierarchy</h4>
                <ol>
                    <li><strong>Workflow-Level (Lowest Priority):</strong> <code>common*</code> options in workflow options apply to all phases and requests</li>
                    <li><strong>Branch-Level:</strong> In branched workflows, branch configuration overrides workflow defaults</li>
                    <li><strong>Phase-Level:</strong> Phase <code>commonConfig</code> property overrides workflow/branch settings for that phase</li>
                    <li><strong>Request Group-Level:</strong> Request group settings override phase/workflow defaults</li>
                    <li><strong>Request-Level (Highest Priority):</strong> Individual request options override all others</li>
                </ol>

                <h4>Example: Workflow Cascading</h4>
                <pre><code class="language-typescript">const phases = [
  {
    id: 'critical-phase',
    requests: [
      { 
        id: 'auth', 
        requestOptions: { 
          reqData: { path: '/auth' },
          attempts: 10  // Highest priority - overrides all
        }
      },
      { 
        id: 'validate', 
        requestOptions: { 
          reqData: { path: '/validate' }
          // Uses phase commonConfig (7 attempts)
        }
      }
    ],
    // Phase-Level Configuration
    commonConfig: {
      commonAttempts: 7,              // Overrides workflow's 3
      commonWait: 3000,               // Overrides workflow's 1000
      commonRetryStrategy: RETRY_STRATEGIES.EXPONENTIAL
    }
  },
  {
    id: 'data-fetch',
    concurrentExecution: true,
    requests: [
      { 
        id: 'users', 
        groupId: 'important',
        requestOptions: { 
          reqData: { path: '/users' }
          // Uses request group settings (5 attempts)
        }
      },
      { 
        id: 'products', 
        requestOptions: { 
          reqData: { path: '/products' }
          // Uses workflow defaults (3 attempts)
        }
      }
    ]
    // No commonConfig, uses workflow defaults
  }
];

await stableWorkflow(phases, {
  workflowId: 'config-cascade-demo',
  
  // Workflow-Level (applies to all phases)
  commonRequestData: { 
    hostname: 'api.example.com',
    headers: { 'Authorization': 'Bearer token' }
  },
  commonAttempts: 3,
  commonWait: 1000,
  commonRetryStrategy: RETRY_STRATEGIES.LINEAR,
  
  // Request Group-Level
  requestGroups: [
    {
      groupId: 'important',
      commonAttempts: 5,              // Overrides workflow's 3
      commonWait: 2000                // Overrides workflow's 1000
    }
  ]
});

// Final Configuration Applied:
// auth:     10 attempts, 3000ms wait (request > phase)
// validate: 7 attempts,  3000ms wait (phase > workflow)
// users:    5 attempts,  2000ms wait (group > workflow)
// products: 3 attempts,  1000ms wait (workflow defaults)</code></pre>

                <h4>Example: Branched Workflow Cascading</h4>
                <pre><code class="language-typescript">const branches = [
  {
    branchId: 'payment-branch',
    phases: [
      {
        id: 'authorize',
        requests: [
          { 
            id: 'check-funds', 
            requestOptions: { 
              reqData: { path: '/payment/authorize' },
              attempts: 8  // Request-level (highest priority)
            }
          }
        ],
        commonConfig: {
          commonAttempts: 6,          // Phase-level
          commonWait: 2000
        }
      }
    ],
    commonConfig: {
      commonAttempts: 4,              // Branch-level
      commonWait: 1500
    }
  },
  {
    branchId: 'notification-branch',
    phases: [
      {
        id: 'send-email',
        requests: [
          { 
            id: 'email', 
            requestOptions: { 
              reqData: { path: '/notify/email' }
              // Uses branch defaults (2 attempts)
            }
          }
        ]
        // No phase commonConfig, uses branch settings
      }
    ],
    commonConfig: {
      commonAttempts: 2,              // Branch-level
      commonWait: 500
    }
  }
];

await stableWorkflow([], {
  workflowId: 'branched-cascade',
  enableBranchExecution: true,
  branches,
  
  // Workflow-Level
  commonAttempts: 3,                  // Lowest priority
  commonWait: 1000,
  commonRequestData: { 
    hostname: 'api.example.com' 
  }
});

// Final Configuration Applied:
// check-funds: 8 attempts, 2000ms wait (request > phase > branch > workflow)
// email:       2 attempts, 500ms wait  (branch > workflow)</code></pre>

                <h3>Configuration Precedence Rules</h3>
                <p>When the same configuration property is defined at multiple levels:</p>
                
                <h4>API Gateway Priority (High to Low)</h4>
                <pre><code class="language-text">Request Options
    ↓
Request Group Options
    ↓
Gateway common* Options</code></pre>

                <h4>Workflow Priority (High to Low)</h4>
                <pre><code class="language-text">Request Options
    ↓
Request Group Options
    ↓
Phase commonConfig
    ↓
Branch commonConfig (in branched workflows)
    ↓
Workflow common* Options</code></pre>
            </section>

            <section id="state-buffers" class="doc-section">
                <h2>State Buffers</h2>
                <h3>Overview</h3>
                <p>Buffers provide a mechanism for sharing data across different parts of your workflows without relying on global variables. There are two types of buffers:</p>
                <ul>
                    <li><strong>commonBuffer</strong> - Request-level buffer for individual requests in <code>stableRequest</code></li>
                    <li><strong>sharedBuffer</strong> - Gateway/Workflow-level buffer shared across all requests in <code>stableApiGateway</code> and <code>stableWorkflow</code></li>
                </ul>

                <h3>The Override Rule</h3>
                <p class="highlight-box"><strong>Important:</strong> When both <code>commonBuffer</code> and <code>sharedBuffer</code> are present, <code>sharedBuffer</code> takes precedence and completely overrides <code>commonBuffer</code> for that execution context.</p>

                <h3>commonBuffer - Request-Level State</h3>
                <p>Used in <code>stableRequest</code> to maintain state across retry attempts and hooks for a single request.</p>

                <h4>Use Cases</h4>
                <ul>
                    <li>Store authentication tokens obtained during pre-execution</li>
                    <li>Track retry-specific metadata</li>
                    <li>Pass data between request hooks (preExecution, responseAnalyzer, handleErrors)</li>
                    <li>Accumulate information across multiple retry attempts</li>
                </ul>

                <h4>Example: Using commonBuffer</h4>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { 
    hostname: 'api.example.com', 
    path: '/protected-resource' 
  },
  resReq: true,
  attempts: 3,
  
  // Initialize buffer
  commonBuffer: {
    attemptCount: 0,
    errors: []
  },
  
  // Pre-execution: Modify request based on buffer
  preExecution: {
    handler: async ({ reqData, sharedBuffer, attempt }) => {
      // sharedBuffer here refers to commonBuffer for stableRequest
      sharedBuffer.attemptCount = attempt;
      
      // Add dynamic authentication if not already present
      if (!sharedBuffer.authToken) {
        sharedBuffer.authToken = await getAuthToken();
      }
      
      reqData.headers = {
        'Authorization': `Bearer ${sharedBuffer.authToken}`,
        'X-Attempt': attempt.toString()
      };
      
      return reqData;
    }
  },
  
  // Response analyzer: Use buffer to track patterns
  responseAnalyzer: async ({ data, status, sharedBuffer }) => {
    if (status === 401) {
      // Auth token expired, clear it for retry
      delete sharedBuffer.authToken;
      return false; // Retry
    }
    return true;
  },
  
  // Error handler: Accumulate errors in buffer
  handleErrors: async ({ error, sharedBuffer, attempt }) => {
    sharedBuffer.errors.push({
      attempt,
      error: error.message,
      timestamp: new Date().toISOString()
    });
    console.log(`Error history:`, sharedBuffer.errors);
  }
});</code></pre>

                <h3>sharedBuffer - Gateway/Workflow-Level State</h3>
                <p>Used in <code>stableApiGateway</code> and <code>stableWorkflow</code> to share state across multiple requests and phases.</p>

                <h4>Use Cases</h4>
                <ul>
                    <li>Share authentication tokens across all requests</li>
                    <li>Pass data from one phase to another in workflows</li>
                    <li>Accumulate results across multiple requests</li>
                    <li>Implement workflow-level state machines</li>
                    <li>Track global metrics (total processed items, errors, etc.)</li>
                    <li>Store checkpoint data for workflow resumption</li>
                </ul>

                <h4>Example: API Gateway with sharedBuffer</h4>
                <pre><code class="language-typescript">const requests = [
  {
    id: 'login',
    requestOptions: {
      reqData: { 
        hostname: 'api.example.com',
        path: '/auth/login',
        method: 'POST',
        body: { username: 'user', password: 'pass' }
      },
      resReq: true,
      preExecution: {
        handler: async ({ reqData, sharedBuffer }) => {
          // First request - no token needed
          return reqData;
        }
      }
    }
  },
  {
    id: 'get-profile',
    requestOptions: {
      reqData: { 
        hostname: 'api.example.com',
        path: '/user/profile'
      },
      resReq: true,
      preExecution: {
        handler: async ({ reqData, sharedBuffer }) => {
          // Use token from previous request
          reqData.headers = {
            'Authorization': `Bearer ${sharedBuffer.authToken}`
          };
          return reqData;
        }
      }
    }
  },
  {
    id: 'get-orders',
    requestOptions: {
      reqData: { 
        hostname: 'api.example.com',
        path: '/user/orders'
      },
      resReq: true,
      preExecution: {
        handler: async ({ reqData, sharedBuffer }) => {
          // Reuse same token
          reqData.headers = {
            'Authorization': `Bearer ${sharedBuffer.authToken}`
          };
          return reqData;
        }
      }
    }
  }
];

await stableApiGateway(requests, {
  concurrentExecution: false, // Sequential for proper token flow
  
  // sharedBuffer is accessible to all requests
  sharedBuffer: {
    authToken: null,
    userProfile: null,
    totalOrders: 0
  },
  
  // Common success handler updates shared state
  commonHandleSuccessfulAttemptData: async ({ data, sharedBuffer, executionContext }) => {
    if (executionContext.requestId === 'login') {
      sharedBuffer.authToken = data.token;
      console.log('Auth token stored in sharedBuffer');
    } else if (executionContext.requestId === 'get-profile') {
      sharedBuffer.userProfile = data;
    } else if (executionContext.requestId === 'get-orders') {
      sharedBuffer.totalOrders = data.length;
    }
  }
});

// After execution, sharedBuffer contains all accumulated data
console.log('Total orders:', sharedBuffer.totalOrders);</code></pre>

                <h4>Example: Workflow with sharedBuffer</h4>
                <pre><code class="language-typescript">const phases = [
  {
    id: 'authentication',
    requests: [{
      id: 'auth',
      requestOptions: {
        reqData: { 
          hostname: 'api.example.com',
          path: '/auth/login',
          method: 'POST',
          body: { username: 'user', password: 'pass' }
        },
        resReq: true
      }
    }]
  },
  {
    id: 'fetch-data',
    concurrentExecution: true,
    requests: [
      { 
        id: 'users', 
        requestOptions: { 
          reqData: { path: '/users' },
          resReq: true,
          preExecution: {
            handler: async ({ reqData, sharedBuffer }) => {
              // Use token from auth phase
              reqData.headers = {
                'Authorization': `Bearer ${sharedBuffer.authToken}`
              };
              return reqData;
            }
          }
        }
      },
      { 
        id: 'products', 
        requestOptions: { 
          reqData: { path: '/products' },
          resReq: true,
          preExecution: {
            handler: async ({ reqData, sharedBuffer }) => {
              // Same token for all requests
              reqData.headers = {
                'Authorization': `Bearer ${sharedBuffer.authToken}`
              };
              return reqData;
            }
          }
        }
      }
    ]
  },
  {
    id: 'process',
    requests: [{
      id: 'analytics',
      requestOptions: {
        reqData: { 
          path: '/analytics',
          method: 'POST',
          body: {} // Will be populated from sharedBuffer
        },
        resReq: false,
        preExecution: {
          handler: async ({ reqData, sharedBuffer }) => {
            // Use data from previous phases
            reqData.body = {
              userCount: sharedBuffer.users?.length || 0,
              productCount: sharedBuffer.products?.length || 0
            };
            reqData.headers = {
              'Authorization': `Bearer ${sharedBuffer.authToken}`
            };
            return reqData;
          }
        }
      }
    }]
  }
];

await stableWorkflow(phases, {
  workflowId: 'data-sync',
  commonRequestData: { hostname: 'api.example.com' },
  
  // sharedBuffer accessible across all phases
  sharedBuffer: {
    authToken: null,
    users: [],
    products: []
  },
  
  // Store successful response data in sharedBuffer
  handlePhaseCompletion: async ({ phaseResult, sharedBuffer }) => {
    if (phaseResult.phaseId === 'authentication') {
      const authResponse = phaseResult.responses.find(r => r.requestId === 'auth');
      if (authResponse?.success) {
        sharedBuffer.authToken = authResponse.data.token;
      }
    } else if (phaseResult.phaseId === 'fetch-data') {
      phaseResult.responses.forEach(response => {
        if (response.requestId === 'users' && response.success) {
          sharedBuffer.users = response.data;
        } else if (response.requestId === 'products' && response.success) {
          sharedBuffer.products = response.data;
        }
      });
    }
  }
});</code></pre>

                <h3>Override Behavior: sharedBuffer vs commonBuffer</h3>
                <p>When a request has both <code>commonBuffer</code> in its options and is executed within a context that provides <code>sharedBuffer</code> (API Gateway or Workflow), the <code>sharedBuffer</code> completely replaces <code>commonBuffer</code>.</p>

                <h4>Example: Understanding the Override</h4>
                <pre><code class="language-typescript">const requests = [
  {
    id: 'request-1',
    requestOptions: {
      reqData: { hostname: 'api.example.com', path: '/data1' },
      resReq: true,
      
      // This commonBuffer will be IGNORED
      commonBuffer: {
        source: 'request-level',
        value: 'ignored'
      },
      
      preExecution: {
        handler: async ({ sharedBuffer }) => {
          // sharedBuffer here refers to gateway's sharedBuffer, NOT commonBuffer
          console.log(sharedBuffer.source); // Outputs: 'gateway-level'
          console.log(sharedBuffer.value);  // Outputs: 'active'
          
          // Modifications affect the gateway's sharedBuffer
          sharedBuffer.modifiedBy = 'request-1';
          return reqData;
        }
      }
    }
  },
  {
    id: 'request-2',
    requestOptions: {
      reqData: { hostname: 'api.example.com', path: '/data2' },
      preExecution: {
        handler: async ({ sharedBuffer }) => {
          // Can see modifications from request-1
          console.log(sharedBuffer.modifiedBy); // Outputs: 'request-1'
          return reqData;
        }
      }
    }
  }
];

await stableApiGateway(requests, {
  concurrentExecution: false,
  
  // This sharedBuffer OVERRIDES all request-level commonBuffers
  sharedBuffer: {
    source: 'gateway-level',
    value: 'active'
  }
});

// Rule: sharedBuffer (gateway/workflow) > commonBuffer (request)</code></pre>

                <h4>Standalone Request vs Gateway Context</h4>
                <pre><code class="language-typescript">// Scenario 1: Standalone stableRequest - commonBuffer is used
await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  commonBuffer: { 
    mode: 'standalone',
    counter: 0 
  },
  preExecution: {
    handler: async ({ sharedBuffer }) => {
      // sharedBuffer refers to commonBuffer in this context
      console.log(sharedBuffer.mode); // 'standalone'
      sharedBuffer.counter++;
      return reqData;
    }
  }
});

// Scenario 2: Same request config in API Gateway - sharedBuffer overrides
await stableApiGateway([{
  id: 'req1',
  requestOptions: {
    reqData: { hostname: 'api.example.com', path: '/data' },
    commonBuffer: { 
      mode: 'standalone',  // IGNORED
      counter: 0           // IGNORED
    },
    preExecution: {
      handler: async ({ sharedBuffer }) => {
        // sharedBuffer refers to gateway's sharedBuffer
        console.log(sharedBuffer.mode); // 'gateway'
        sharedBuffer.counter++;
        return reqData;
      }
    }
  }
}], {
  sharedBuffer: {
    mode: 'gateway',
    counter: 100  // This is what gets used
  }
});</code></pre>
            </section>

            <section id="retry-strategies" class="doc-section">
                <h2>Retry Strategies</h2>
                <p>Automatically retry failed requests with sophisticated backoff strategies.</p>

                <h3>Fixed Delay</h3>
                <p>Constant wait time between each retry attempt.</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  attempts: 5,
  wait: 1000,                     // 1s, 1s, 1s, 1s, 1s
  retryStrategy: RETRY_STRATEGIES.FIXED
});</code></pre>

                <h3>Linear Backoff</h3>
                <p>Incrementally increasing delays.</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  attempts: 5,
  wait: 1000,                     // 1s, 2s, 3s, 4s, 5s
  retryStrategy: RETRY_STRATEGIES.LINEAR
});</code></pre>

                <h3>Exponential Backoff</h3>
                <p>Exponentially growing delays (recommended for most use cases).</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  attempts: 5,
  wait: 1000,                     // 1s, 2s, 4s, 8s, 16s
  retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
  maxAllowedWait: 30000           // Cap at 30 seconds
});</code></pre>

                <h3>Jitter</h3>
                <p>Add randomness to prevent thundering herd problems.</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  attempts: 5,
  wait: 1000,
  retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
  jitter: 500                     // ±500ms random variation
});</code></pre>

                <h3>Custom Response Validation</h3>
                <p>Retry based on response content, not just HTTP status.</p>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/job/status' },
  resReq: true,
  attempts: 10,
  wait: 2000,
  responseAnalyzer: async ({ data }) => {
    // Retry until job is complete
    return data.status === 'completed';
  }
});</code></pre>
            </section>

            <section id="circuit-breaker" class="doc-section">
                <h2>Circuit Breaker Pattern</h2>
                <p>Prevent cascade failures and system overload with built-in circuit breakers.</p>

                <h3>Circuit Breaker States</h3>
                <ul>
                    <li><strong>CLOSED:</strong> Normal operation, requests flow through</li>
                    <li><strong>OPEN:</strong> Too many failures detected, requests blocked immediately</li>
                    <li><strong>HALF_OPEN:</strong> Testing if service recovered, limited requests allowed</li>
                </ul>

                <h3>Basic Usage</h3>
                <pre><code class="language-typescript">import { stableRequest } from '@emmvish/stable-request';

await stableRequest({
  reqData: { hostname: 'unreliable-api.example.com', path: '/data' },
  attempts: 3,
  circuitBreaker: {
    failureThreshold: 5,          // Open after 5 failures
    successThreshold: 2,          // Close after 2 successes in half-open
    timeout: 60000,               // Wait 60s before trying again (half-open)
    trackIndividualAttempts: false // Track at request level (not attempt level)
  }
});</code></pre>

                <h3>Shared Circuit Breaker</h3>
                <p>Use the same circuit breaker instance across multiple requests or workflows:</p>
                <pre><code class="language-typescript">import { CircuitBreaker } from '@emmvish/stable-request';

const sharedBreaker = new CircuitBreaker({
  failureThresholdPercentage: 50,
  minimumRequests: 5,
  recoveryTimeoutMs: 60000,
  successThresholdPercentage: 70,
  halfOpenMaxRequests: 3
});

// Use in multiple requests
await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/users' },
  circuitBreaker: sharedBreaker
});

await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/orders' },
  circuitBreaker: sharedBreaker
});

// Check circuit breaker state
const state = sharedBreaker.getState();
console.log(`State: ${state.state}`);
console.log(`Failure rate: ${state.failureRate}%`);</code></pre>

                <h3>Workflow-Level Circuit Breaker</h3>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  commonRequestData: { hostname: 'api.example.com' },
  circuitBreaker: sharedBreaker,  // Shared across all phases
  commonAttempts: 3
});</code></pre>
            </section>

            <section id="caching" class="doc-section">
                <h2>Response Caching</h2>
                <p>Cache responses to reduce load and improve performance.</p>

                <h3>Basic Caching</h3>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  resReq: true,
  cache: {
    ttl: 300000                   // Cache for 5 minutes
  }
});</code></pre>

                <h3>Shared Cache Instance</h3>
                <pre><code class="language-typescript">import { CacheManager } from '@emmvish/stable-request';

const cache = new CacheManager({ ttl: 300000 });

// Use across multiple requests
await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/users' },
  cache: { cacheInstance: cache }
});

await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/users' },
  cache: { cacheInstance: cache }  // Reuses cached data
});</code></pre>

                <h3>Workflow-Level Caching</h3>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  commonCache: {
    ttl: 300000
  }
});</code></pre>
            </section>

            <section id="rate-limiting" class="doc-section">
                <h2>Rate Limiting & Concurrency Control</h2>

                <h3>Rate Limiting</h3>
                <p>Control request rates to respect API quotas.</p>
                <pre><code class="language-typescript">import { RateLimiter } from '@emmvish/stable-request';

const limiter = new RateLimiter(100, 60000); // 100 requests per minute

await stableApiGateway(requests, {
  rateLimit: {
    maxRequests: 100,
    windowMs: 60000
  }
});</code></pre>

                <h3>Concurrency Limiting</h3>
                <p>Control the maximum number of simultaneous requests.</p>
                <pre><code class="language-typescript">await stableApiGateway(requests, {
  concurrentExecution: true,
  maxConcurrentRequests: 5        // Max 5 simultaneous requests
});</code></pre>

                <h3>Combined Rate & Concurrency Limiting</h3>
                <pre><code class="language-typescript">await stableApiGateway(requests, {
  concurrentExecution: true,
  maxConcurrentRequests: 10,
  rateLimit: {
    maxRequests: 100,
    windowMs: 60000
  }
});</code></pre>
            </section>

            <section id="workflow-patterns" class="doc-section">
                <h2>Workflow Execution Patterns</h2>

                <h3 id="sequential-concurrent">Sequential & Concurrent Phases</h3>
                    
                    <h4>Sequential Phases (Default)</h4>
                    <p>Phases execute one after another.</p>
                    <pre><code class="language-typescript">const result = await stableWorkflow(phases, {
  concurrentPhaseExecution: false  // Default
});</code></pre>

                    <h4>Concurrent Phases</h4>
                    <p>All phases execute simultaneously.</p>
                    <pre><code class="language-typescript">const result = await stableWorkflow(phases, {
  concurrentPhaseExecution: true
});</code></pre>

                    <h4>Concurrent Requests within Phase</h4>
                    <pre><code class="language-typescript">const phases = [
  {
    id: 'fetch-data',
    concurrentExecution: true,    // Requests in parallel
    requests: [...]
  }
];</code></pre>

                <h3 id="mixed-execution">Mixed Execution Mode</h3>
                    <p>Mark specific phases for concurrent execution while others run sequentially.</p>
                    <pre><code class="language-typescript">const phases = [
  {
    id: 'auth',
    requests: [...]               // Runs first (sequential)
  },
  {
    id: 'fetch-users',
    markConcurrentPhase: true,    // Concurrent group starts
    requests: [...]
  },
  {
    id: 'fetch-products',
    markConcurrentPhase: true,    // Part of concurrent group
    requests: [...]
  },
  {
    id: 'process',
    requests: [...]               // Runs after concurrent group
  }
];

const result = await stableWorkflow(phases, {
  enableMixedExecution: true
});</code></pre>

                <h3 id="non-linear">Non-Linear Workflows</h3>
                    <p>Implement conditional logic with phase decision hooks.</p>
                    
                    <h4>Available Actions</h4>
                    <ul>
                        <li><code>CONTINUE</code>: Proceed to next phase normally</li>
                        <li><code>SKIP</code>: Skip to a specific phase</li>
                        <li><code>JUMP</code>: Jump backwards to re-execute a phase</li>
                        <li><code>REPLAY</code>: Re-execute current phase</li>
                        <li><code>TERMINATE</code>: End workflow immediately</li>
                    </ul>

                    <pre><code class="language-typescript">import { PHASE_DECISION_ACTIONS } from '@emmvish/stable-request';

const phases = [
  {
    id: 'validate',
    requests: [...],
    phaseDecisionHook: async ({ phaseResult, sharedBuffer }) => {
      if (!phaseResult.success) {
        return { action: PHASE_DECISION_ACTIONS.TERMINATE };
      }
      return { action: PHASE_DECISION_ACTIONS.CONTINUE };
    }
  },
  {
    id: 'process',
    requests: [...],
    phaseDecisionHook: async ({ phaseResult, sharedBuffer, retryCount }) => {
      if (phaseResult.failedRequests > 0 && retryCount < 3) {
        return { action: PHASE_DECISION_ACTIONS.REPLAY }; // Retry phase
      }
      return { action: PHASE_DECISION_ACTIONS.CONTINUE };
    }
  },
  {
    id: 'finalize',
    requests: [...]
  }
];

const result = await stableWorkflow(phases, {
  enableNonLinearExecution: true,
  maxWorkflowIterations: 1000     // Prevent infinite loops
});</code></pre>

                <h3 id="branched">Branched Workflows</h3>
                    <p>Execute independent branches of work, each with its own phases.</p>
                    
                    <pre><code class="language-typescript">const branches = [
  {
    branchId: 'user-service',
    concurrentBranch: false,      // Phases run sequentially in this branch
    phases: [
      { id: 'validate-user', requests: [...] },
      { id: 'update-profile', requests: [...] }
    ]
  },
  {
    branchId: 'inventory-service',
    concurrentBranch: false,
    phases: [
      { id: 'check-stock', requests: [...] },
      { id: 'reserve-items', requests: [...] }
    ]
  },
  {
    branchId: 'payment-service',
    concurrentBranch: false,
    phases: [
      { id: 'authorize-payment', requests: [...] },
      { id: 'capture-payment', requests: [...] }
    ]
  }
];

const result = await stableWorkflow([], {
  enableBranchExecution: true,
  branches,
  concurrentBranchExecution: true,  // Branches run in parallel
  handleBranchCompletion: async ({ branchId, success, branchResults }) => {
    console.log(`Branch ${branchId}: ${success ? 'SUCCESS' : 'FAILED'}`);
  }
});</code></pre>

                    <h4>Branch Decision Hooks</h4>
                    <pre><code class="language-typescript">const branches = [
  {
    branchId: 'critical-service',
    phases: [{
      id: 'critical-operation',
      requests: [...],
      phaseDecisionHook: async ({ phaseResult }) => {
        if (!phaseResult.success) {
          return { 
            action: PHASE_DECISION_ACTIONS.TERMINATE,
            terminateWorkflow: true  // Stop entire workflow
          };
        }
        return { action: PHASE_DECISION_ACTIONS.CONTINUE };
      }
    }]
  }
];

const result = await stableWorkflow([], {
  enableBranchExecution: true,
  branches,
  handleBranchDecision: async ({ branchId, decision }) => {
    logger.warn(`Branch ${branchId} decision:`, decision);
  }
});</code></pre>
            </section>

            <section id="observability" class="doc-section">
                <h2>Observability & Hooks</h2>
                <p>Comprehensive hooks for monitoring, logging, and debugging.</p>

                <h3>Request-Level Hooks</h3>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  
  // Called on each failed attempt
  handleErrors: async ({ error, errorLog, attempt, totalAttempts }) => {
    logger.error(`Attempt ${attempt}/${totalAttempts} failed:`, errorLog);
  },
  
  // Called on each successful attempt
  handleSuccessfulAttemptData: async ({ data, status, attempt }) => {
    logger.info(`Attempt ${attempt} succeeded with status ${status}`);
  },
  
  // Validate responses (return false to retry)
  responseAnalyzer: async ({ data, status, headers }) => {
    return status === 200 && data.status === 'success';
  },
  
  // Handle final error after all retries exhausted
  finalErrorAnalyzer: async ({ error, allErrors }) => {
    logger.error('All attempts failed:', allErrors);
    return false; // Throw error (true = suppress)
  }
});</code></pre>

                <h3>Workflow-Level Hooks</h3>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  // Called after each phase completes
  handlePhaseCompletion: async ({ 
    phaseResult, 
    sharedBuffer,
    params
  }) => {
    logger.info(`Phase ${phaseResult.phaseId} completed:`, {
      success: phaseResult.success,
      totalRequests: phaseResult.totalRequests,
      executionTime: phaseResult.executionTime
    });
  },
  
  // Called when phase encounters error
  handlePhaseError: async ({ error, phaseResult, params }) => {
    logger.error(`Phase ${phaseResult.phaseId} failed:`, error);
  },
  
  // Called for non-linear decisions
  handlePhaseDecision: async ({ workflowId, decision, phaseResult }) => {
    console.log(`Phase decision: ${decision.action}`);
    if (decision.targetPhaseId) {
      console.log(`Target: ${decision.targetPhaseId}`);
    }
  },
  
  // Called when branch needs to take a decision
  handleBranchDecision: async ({ workflowId, branchId, branchResults, success }) => {
    console.log(`Branch ID: ${branchId}`);
  },

  // Called upon branch completion
  handleBranchCompletion: async ({ workflowId, branchResult }) => {
    console.log(`Branch ${branchResult.branchId} completed`);
  },

  // Pass parameters to workflow hooks
  workflowHookParams: {
    handlePhaseCompletionParams: { environment: 'production' },
    handlePhaseErrorParams: { severity: 'high' }
  },
});</code></pre>
            </section>

            <section id="pre-execution" class="doc-section">
                <h2>Pre-Execution Hook</h2>
                <p>Dynamically modify requests before they are executed. The pre-execution hook allows you to inspect and transform request data based on the current execution state, making it ideal for adding dynamic headers, authentication, or conditional request modifications.</p>

                <h3>Usage</h3>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  preExecution: {
    preExecutionHook: async ({ inputParams, commonBuffer }) => {
      const reqData = { ...inputParams.reqData, hostname: commonBuffer.hostname };
      return { reqData };
    }
  },
  commonBuffer: { hostname: 'abc.com' }
});</code></pre>
            </section>

            <section id="trial-mode" class="doc-section">
                <h2>Trial Mode</h2>
                <p>Test without making real API calls using probabilistic success/failure simulation.</p>

                <h3>Basic Trial Mode</h3>
                <pre><code class="language-typescript">await stableRequest({
  reqData: { hostname: 'api.example.com', path: '/data' },
  resReq: true,
  attempts: 3,
  trialMode: {
    trialModeOn: true,
    successProbability: 0.7,      // 70% chance of success
    trialModeData: { mock: 'data' }
  }
});</code></pre>

                <h3>A/B Testing with Trial Mode</h3>
                <pre><code class="language-typescript">// Test feature flags with different probabilities
const runTest = async (featureName, successRate) => {
  const result = await stableRequest({
    reqData: { hostname: 'api.example.com', path: '/feature-test' },
    resReq: true,
    attempts: 5,
    trialMode: {
      trialModeOn: true,
      successProbability: successRate,
      trialModeData: { feature: featureName, enabled: true }
    }
  });
  
  return result;
};

// Test different configurations
await runTest('feature-A', 0.9);  // 90% success rate
await runTest('feature-B', 0.5);  // 50% success rate</code></pre>
            </section>

            <section id="state-persistence" class="doc-section">
                <h2>State Persistence</h2>
                <p>Persist workflow state to external storage (databases, Redis, file systems) for resilience, recovery, and distributed execution.</p>
                <h3>Configuration</h3>
                <p>State persistence is configured using the <code>StatePersistenceConfig</code> interface:</p>
                <pre><code class="language-typescript">interface StatePersistenceConfig {
  persistenceFunction: (options: StatePersistenceOptions) =&gt; Promise&lt;Record&lt;string, any&gt;&gt; | Record&lt;string, any&gt;;
  persistenceParams?: any;  // Custom parameters passed to your persistence function
  loadBeforeHooks?: boolean;  // Load state before executing hooks (default: false)
  storeAfterHooks?: boolean;  // Store state after hook execution (default: false)
}

interface StatePersistenceOptions {
  executionContext: ExecutionContext;  // Context about current execution
  params?: any;                        // Your custom persistenceParams
  buffer: Record<string, any>;         // The state buffer to store/load
}

interface ExecutionContext {
  workflowId: string;   // Unique workflow identifier
  phaseId?: string;     // Current phase ID (if in a phase)
  branchId?: string;    // Current branch ID (if in a branch)
  requestId?: string;   // Current request ID (if applicable)
}</code></pre>

                <h3>How It Works</h3>
                <p>The persistence function is called in two modes:</p>
                <ul>
                    <li><strong>LOAD Mode:</strong> When <code>buffer</code> is empty/null, return the stored state</li>
                    <li><strong>STORE Mode:</strong> When <code>buffer</code> contains data, save it to your storage</li>
                </ul>
                <pre><code class="language-typescript">// Your persistence function
const myPersistenceFunction = async ({ executionContext, params, buffer }) => {
  if (buffer && Object.keys(buffer).length > 0) {
    // STORE MODE: Save the buffer to storage
    await myStorage.save(executionContext.workflowId, buffer);
    return {};
  } else {
    // LOAD MODE: Return stored state
    const stored = await myStorage.load(executionContext.workflowId);
    return stored || {};  // Return empty object if nothing stored
  }
};</code></pre>
                <h3>Checkpoint-Based Global Persistence</h3>
                <p>Track workflow progress with global checkpoints that persist completed phases:</p>
                <pre><code class="language-typescript">import Redis from 'ioredis';
const redis = new Redis();
async function createCheckpoint({ executionContext, params, buffer }) {
  const { workflowId, phaseId } = executionContext;
  const { ttl = 86400 } = params || {};
  
  const checkpointKey = `checkpoint:${workflowId}`;
  
  if (buffer && Object.keys(buffer).length > 0) {
    // STORE: Save checkpoint with completed phases
    const existingData = await redis.get(checkpointKey);
    const existing = existingData ? JSON.parse(existingData) : {};
    
    const checkpointData = {
      ...existing,
      completedPhases: [...new Set([...(existing.completedPhases || []), ...(buffer.completedPhases || [])])],
      lastPhase: phaseId || existing.lastPhase,
      lastUpdated: new Date().toISOString(),
      progress: buffer.progress || existing.progress || 0,
      processedRecords: buffer.recordsProcessed || existing.processedRecords || 0
    };
    
    await redis.setex(checkpointKey, ttl, JSON.stringify(checkpointData));
    console.log(`Checkpoint saved: ${phaseId} (Progress: ${checkpointData.progress}%)`);
  } else {
    // LOAD: Return checkpoint data
    const data = await redis.get(checkpointKey);
    return data ? JSON.parse(data) : { completedPhases: [], processedRecords: 0 };
  }
  
  return {};
}

// Use global checkpoint for all phases
await stableWorkflow(phases, {
  workflowId: 'migration-12345',
  enableNonLinearExecution: true,
  sharedBuffer: {
    completedPhases: [],
    progress: 0
  },
  commonStatePersistence: {
    persistenceFunction: createCheckpoint,
    persistenceParams: { ttl: 7200 },  // 2 hours
    loadBeforeHooks: true,
    storeAfterHooks: true
  }
});</code></pre>
                <p>Resume workflows from checkpoints with automatic phase skipping:</p>
                <pre><code class="language-typescript">// Resume a workflow from last saved state
async function resumeWorkflow(workflowId: string) {
  const phases = [
    {
      id: 'phase-1',
      requests: [...],
      phaseDecisionHook: async ({ phaseResult, sharedBuffer }) => {
        // Check if this phase already completed (recovery scenario)
        if (sharedBuffer.completedPhases?.includes('phase-1')) {
          console.log('Phase-1 already completed, skipping...');
          return { 
            action: PHASE_DECISION_ACTIONS.SKIP, 
            skipToPhaseId: 'phase-2' 
          };
        }
        
        // Verify success before marking complete
        if (phaseResult.success) {
          sharedBuffer.completedPhases = [...(sharedBuffer.completedPhases || []), 'phase-1'];
          console.log('📊 Phase-1 completed, saving checkpoint...');
          return { action: PHASE_DECISION_ACTIONS.CONTINUE };
        }
        
        return { action: PHASE_DECISION_ACTIONS.TERMINATE };
      },
      statePersistence: {
        persistenceFunction: persistToDatabase,
        persistenceParams: { db },
        loadBeforeHooks: true,
        storeAfterHooks: true
      }
    },
    {
      id: 'phase-2',
      requests: [...],
      phaseDecisionHook: async ({ phaseResult, sharedBuffer }) => {
        if (sharedBuffer.completedPhases?.includes('phase-2')) {
          console.log('Phase-2 already completed, skipping...');
          return { 
            action: PHASE_DECISION_ACTIONS.SKIP, 
            skipToPhaseId: 'phase-3' 
          };
        }
        
        if (phaseResult.success) {
          sharedBuffer.completedPhases = [...(sharedBuffer.completedPhases || []), 'phase-2'];
          return { action: PHASE_DECISION_ACTIONS.CONTINUE };
        }
        
        return { action: PHASE_DECISION_ACTIONS.TERMINATE };
      },
      statePersistence: {
        persistenceFunction: persistToDatabase,
        persistenceParams: { db },
        loadBeforeHooks: true,
        storeAfterHooks: true
      }
    }
  ];
  
  const result = await stableWorkflow(phases, {
    workflowId,
    enableNonLinearExecution: true,
    sharedBuffer: { completedPhases: [] }
  });
  
  return result;
}</code></pre>
            </section>

            <section id="best-practices" class="doc-section">
                <h2>Best Practices</h2>
                <p>Comprehensive guide to building production-ready HTTP workflows using stable-request's full feature set.</p>

                <h3>1. Implement Progressive Retry Strategies</h3>
                <p>Use exponential backoff with jitter for most scenarios to prevent overwhelming services and avoid thundering herd problems.</p>
                <pre><code class="language-typescript">import { stableRequest, RETRY_STRATEGIES } from '@emmvish/stable-request';

await stableRequest({
  reqData: { 
    hostname: 'api.example.com', 
    path: '/data',
    timeout: 5000  // Always set timeouts
  },
  attempts: 5,
  wait: 1000,
  retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
  jitter: 500,                    // ±500ms randomization
  maxAllowedWait: 30000,          // Cap maximum wait time
  logAllErrors: true              // Track all failures
});</code></pre>

                <h3>2. Deploy Circuit Breakers for External Dependencies</h3>
                <p>Prevent cascade failures by implementing circuit breakers for all external API calls. Share circuit breaker instances across related requests.</p>
                <pre><code class="language-typescript">import { CircuitBreaker } from '@emmvish/stable-request';

// Create shared circuit breaker per service
const paymentServiceBreaker = new CircuitBreaker({
  failureThresholdPercentage: 50,   // Open after 50% failure rate
  minimumRequests: 10,              // Need 10 requests to calculate rate
  recoveryTimeoutMs: 60000,         // Wait 60s before testing recovery
  successThresholdPercentage: 80,   // 80% success to close circuit
  halfOpenMaxRequests: 3            // Test with 3 requests in half-open
});

// Use across all payment API requests
await stableRequest({
  reqData: { hostname: 'payment.api.com', path: '/charge' },
  circuitBreaker: paymentServiceBreaker,
  attempts: 3
});

// Monitor circuit state
const state = paymentServiceBreaker.getState();
if (state.state === 'OPEN') {
  metrics.gauge('circuit.payment.open', 1);
}</code></pre>

                <h3>3. Leverage Request Grouping for Different SLAs</h3>
                <p>Separate requests by criticality with different retry policies and timeouts.</p>
                <pre><code class="language-typescript">await stableApiGateway(requests, {
  requestGroups: [
    {
      groupId: 'critical',
      commonAttempts: 7,
      commonWait: 2000,
      commonRetryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
      commonJitter: 500,
      commonMaxAllowedWait: 30000
    },
    {
      groupId: 'optional',
      commonAttempts: 1,
      commonWait: 500
    }
  ]
});</code></pre>

                <h3>4. Enable Intelligent Caching for Read Operations</h3>
                <p>Cache GET requests with appropriate TTL and custom key generation.</p>
                <pre><code class="language-typescript">import { CacheManager } from '@emmvish/stable-request';

const apiCache = new CacheManager({ 
  ttl: 300000,
  maxSize: 500,
  excludeMethods: ['POST', 'PUT', 'PATCH', 'DELETE']
});

await stableRequest({
  reqData: { path: '/users/profile', method: 'GET' },
  cache: { cacheInstance: apiCache, ttl: 600000 }
});</code></pre>

                <h3>5. Build Comprehensive Observability</h3>
                <p>Track all request attempts, failures, and performance metrics.</p>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  commonHandleErrors: async ({ error, errorLog, attempt, executionContext }) =&gt; {
    metrics.increment('api.error', {
      endpoint: executionContext.requestId,
      attempt: attempt.toString()
    });
    logger.error('Request failed', { attempt, error: errorLog });
  },
  
  handlePhaseCompletion: async ({ phaseResult }) =&gt; {
    metrics.histogram('phase.duration', phaseResult.executionTime);
    logger.info('Phase completed', {
      phaseId: phaseResult.phaseId,
      success: phaseResult.success
    });
  }
});</code></pre>

                <h3>6. Master Configuration Cascading</h3>
                <p>Leverage hierarchical configuration for sensible defaults with fine-grained control.</p>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  // Workflow-level defaults (lowest priority)
  commonAttempts: 3,
  commonWait: 1000,
  
  // Group-level overrides
  requestGroups: [{
    groupId: 'critical',
    commonAttempts: 7  // Critical requests get more retries
  }]
});
// Final cascade: Request &gt; Group &gt; Phase &gt; Workflow</code></pre>

                <h3>7. Use Shared Buffers for State Management</h3>
                <p>Share data across phases without global variables.</p>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  sharedBuffer: { configVersion: null, apiKey: null },
  
  handlePhaseCompletion: async ({ phaseResult, sharedBuffer }) =&gt; {
    if (phaseResult.phaseId === 'fetch-config') {
      sharedBuffer.configVersion = phaseResult.responses[0].data.version;
      sharedBuffer.apiKey = phaseResult.responses[0].data.apiKey;
    }
  }
});</code></pre>

                <h3>8. Implement Smart Pre-Execution Hooks</h3>
                <p>Dynamically modify requests based on runtime conditions.</p>
                <pre><code class="language-typescript">await stableRequest({
  commonBuffer: { authToken: null, tokenExpiry: null },
  
  preExecution: {
    handler: async ({ reqData, sharedBuffer, attempt }) =&gt; {
      const now = Date.now();
      if (!sharedBuffer.authToken || now &gt;= sharedBuffer.tokenExpiry) {
        const tokenResponse = await getAuthToken();
        sharedBuffer.authToken = tokenResponse.token;
        sharedBuffer.tokenExpiry = now + (tokenResponse.expiresIn * 1000);
      }
      
      reqData.headers = {
        'Authorization': `Bearer ${sharedBuffer.authToken}`,
        'X-Attempt': attempt.toString()
      };
      return reqData;
    }
  }
});</code></pre>

                <h3>9. Leverage Non-Linear Workflows</h3>
                <p>Implement conditional execution with phase decision hooks.</p>
                <pre><code class="language-typescript">import { PHASE_DECISION_ACTIONS } from '@emmvish/stable-request';

const phases = [{
  id: 'process-data',
  phaseDecisionHook: async ({ phaseResult, retryCount }) =&gt; {
    if (phaseResult.failedRequests &gt; 0 && retryCount &lt; 3) {
      return { action: PHASE_DECISION_ACTIONS.REPLAY };
    }
    if (phaseResult.successfulRequests &gt;= phaseResult.totalRequests * 0.8) {
      return { action: PHASE_DECISION_ACTIONS.CONTINUE };
    }
    return { action: PHASE_DECISION_ACTIONS.TERMINATE };
  }
}];

await stableWorkflow(phases, {
  enableNonLinearExecution: true,
  maxWorkflowIterations: 1000
});</code></pre>

                <h3>10. Deploy Branched Workflows</h3>
                <p>Execute independent service calls in parallel branches.</p>
                <pre><code class="language-typescript">const branches = [
  {
    branchId: 'payment-service',
    phases: [
      { id: 'authorize-payment', requests: [...] },
      { id: 'capture-payment', requests: [...] }
    ]
  },
  {
    branchId: 'notification-service',
    concurrentBranch: true,
    phases: [
      { id: 'send-email', requests: [...] },
      { id: 'send-sms', requests: [...] }
    ]
  }
];

await stableWorkflow([], {
  enableBranchExecution: true,
  branches,
  concurrentBranchExecution: true
});</code></pre>

                <h3>11. Implement State Persistence</h3>
                <p>Enable recovery from failures with state persistence.</p>
                <pre><code class="language-typescript">import Redis from 'ioredis';
const redis = new Redis();

const persistToRedis = async ({ executionContext, buffer }) =&gt; {
  const key = `workflow:${executionContext.workflowId}`;
  if (buffer && Object.keys(buffer).length &gt; 0) {
    await redis.setex(key, 7200, JSON.stringify(buffer));
    return {};
  }
  const data = await redis.get(key);
  return data ? JSON.parse(data) : {};
};

await stableWorkflow(phases, {
  commonStatePersistence: {
    persistenceFunction: persistToRedis,
    loadBeforeHooks: true,
    storeAfterHooks: true
  }
});</code></pre>

                <h3>12. Use Trial Mode for Testing</h3>
                <p>Test workflow logic without real API calls.</p>
                <pre><code class="language-typescript">await stableWorkflow(phases, {
  commonTrialMode: {
    trialModeOn: true,
    successProbability: 0.7,
    trialModeData: { mock: 'data' }
  }
});</code></pre>

                <h3>13. Validate Responses Beyond HTTP Status</h3>
                <p>Implement custom response validation.</p>
                <pre><code class="language-typescript">await stableRequest({
  responseAnalyzer: async ({ data, status }) =&gt; {
    if (status !== 200) return false;
    if (data.status === 'processing') return false; // Retry
    if (data.status === 'completed') return true;
    throw new Error(`Unexpected status: ${data.status}`);
  }
});</code></pre>

                <h3>14. Configure Rate Limiting & Concurrency</h3>
                <p>Respect API quotas and prevent resource exhaustion.</p>
                <pre><code class="language-typescript">await stableApiGateway(requests, {
  concurrentExecution: true,
  maxConcurrentRequests: 10,
  rateLimit: {
    maxRequests: 100,
    windowMs: 60000
  }
});</code></pre>

                <h3>15. Production-Ready Complete Example</h3>
                <p>Combining all patterns for robust production systems.</p>
                <pre><code class="language-typescript">import { 
  stableWorkflow, 
  RETRY_STRATEGIES, 
  PHASE_DECISION_ACTIONS,
  CircuitBreaker, 
  CacheManager 
} from '@emmvish/stable-request';

const paymentBreaker = new CircuitBreaker({
  failureThresholdPercentage: 50,
  minimumRequests: 10,
  recoveryTimeoutMs: 60000
});
const apiCache = new CacheManager({ ttl: 300000 });

const result = await stableWorkflow([], {
  workflowId: 'order-processing',
  enableBranchExecution: true,
  branches: [
    {
      branchId: 'payment',
      phases: [{
        id: 'charge',
        requests: [{
          id: 'payment',
          requestOptions: {
            reqData: { path: '/payment/charge', timeout: 10000 },
            attempts: 7,
            retryStrategy: RETRY_STRATEGIES.EXPONENTIAL,
            jitter: 500,
            circuitBreaker: paymentBreaker,
            preExecution: {
              handler: async ({ reqData, sharedBuffer }) =&gt; {
                reqData.body = { amount: sharedBuffer.orderAmount };
                return reqData;
              }
            }
          }
        }],
        statePersistence: {
          persistenceFunction: persistToRedis,
          loadBeforeHooks: true,
          storeAfterHooks: true
        }
      }]
    }
  ],
  sharedBuffer: { orderAmount: 100, completedPhases: [] },
  maxConcurrentRequests: 10,
  rateLimit: { maxRequests: 100, windowMs: 60000 },
  commonHandleErrors: async ({ error, attempt, executionContext }) =&gt; {
    metrics.increment('error', { request: executionContext.requestId });
  }
});</code></pre>
            </section>
        </main>
    </div>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4>stable-request</h4>
                    <p>Production-grade HTTP Workflow Engine for Node.js</p>
                </div>
                <div class="footer-section">
                    <h4>Links</h4>
                    <ul>
                        <li><a href="https://github.com/Emmvish/stable-request/blob/main/docs/api-references.md">API Reference</a></li>
                        <li><a href="https://github.com/Emmvish/stable-request/issues">Report Issues</a></li>
                        <li><a href="https://github.com/Emmvish/stable-request">GitHub</a></li>
                        <li><a href="https://www.npmjs.com/package/@emmvish/stable-request">npm</a></li>
                        <li><a href="index.html">Home</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Resources</h4>
                    <ul>
                        <li><a href="documentation.html">Documentation</a></li>
                        <li><a href="examples.html">Examples</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2026 Manish Varma (Emmvish).</p>
            </div>
        </div>
    </footer>

    <script>
        hljs.highlightAll();
        
        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });

        // Highlight active section in sidebar
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    document.querySelectorAll('.docs-nav a').forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === `#${id}`) {
                            link.classList.add('active');
                        }
                    });
                }
            });
        }, { rootMargin: '-20% 0px -80% 0px' });

        document.querySelectorAll('.doc-section').forEach(section => {
            observer.observe(section);
        });
        
        // Add copy buttons to all code blocks
        document.querySelectorAll('pre code').forEach((codeBlock) => {
            const pre = codeBlock.parentElement;
            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = 'Copy';
            button.setAttribute('aria-label', 'Copy code to clipboard');
            
            button.addEventListener('click', async () => {
                const code = codeBlock.textContent;
                try {
                    await navigator.clipboard.writeText(code);
                    button.textContent = 'Copied!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    button.textContent = 'Failed';
                    setTimeout(() => {
                        button.textContent = 'Copy';
                    }, 2000);
                }
            });
            
            pre.style.position = 'relative';
            pre.appendChild(button);
        });
    </script>
</body>
</html>
